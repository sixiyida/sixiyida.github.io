[{"content":"LangSmithè°ƒç ”è®°å½• ä¸»è¦åŠŸèƒ½ Observability - å¯è§‚æµ‹æ€§\nEvaluation - è¯„ä¼°ï¼ŒæŒ‡çš„æ˜¯è¯„ä¼°ä»€ä¹ˆï¼Ÿ\nPrompt Engineering - æç¤ºè¯å·¥å…·ï¼Ÿ\nObservation Trace OpenAIæ¨¡å‹è°ƒç”¨ 1 2 3 from langsmith.wrappers import wrap_openai openai_client = wrap_openai(OpenAI()) ä½¿ç”¨wrapperåŒ…è£…clientï¼Œå°±å¯ä»¥æ¥å…¥langsmithã€‚\nTraceæ•´ä¸ªåº”ç”¨ ä½¿ç”¨@traceableè£…é¥°å™¨ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 from openai import OpenAI from langsmith import traceable from langsmith.wrappers import wrap_openai openai_client = wrap_openai(OpenAI()) def retriever(query: str): //... @traceable def rag(question): //... æ³¨ï¼šTraceableå¯ä»¥è£…é¥°ä»»ä½•å‡½æ•°ï¼Œè£…é¥°åå°±å¯ä»¥åœ¨LangSmithè§‚æµ‹inputå’Œoutputã€‚\nTraceå¬å› ä½¿ç”¨@traceableè£…é¥°å™¨ï¼š\n1 2 3 4 @traceable(run_type=\u0026#34;retriever\u0026#34;) def retriever(query: str): results = [\u0026#34;Harrison worked at Kensho\u0026#34;] return results Feedback/Metadata 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //MetaData //æ–¹å¼1ï¼šåœ¨è£…é¥°å™¨ä¸­åŠ å…ƒæ•°æ® @traceable(metadata={\u0026#34;llm\u0026#34;: \u0026#34;gpt-4o-mini\u0026#34;}) def rag(question): //... //æ–¹å¼2ï¼šåœ¨è°ƒç”¨ååŠ å‚æ•° import uuid run_id = str(uuid.uuid4()) rag( \u0026#34;where did harrison work\u0026#34;, langsmith_extra={\u0026#34;run_id\u0026#34;: run_id, \u0026#34;metadata\u0026#34;: {\u0026#34;user_id\u0026#34;: \u0026#34;harrison\u0026#34;}} ) //åé¦ˆä¸metadataç›¸å…³è”çš„feedback from langsmith import Client ls_client = Client() ls_client.create_feedback( run_id, key=\u0026#34;user-score\u0026#34;, score=1.0, ) å¼‚æ­¥ä»»åŠ¡æäº¤Trace 1 2 3 4 5 6 7 8 9 10 11 12 13 from langsmith import Client client = Client() @traceable(client=client) async def my_traced_func(): # Your code here... pass try: await my_traced_func() finally: await client.flush() ","date":"2025-06-26T00:00:00Z","permalink":"https://sixiyida.github.io/p/langsmith%E8%B0%83%E7%A0%94%E8%AE%B0%E5%BD%95/","title":"LangSmithè°ƒç ”è®°å½•"},{"content":"å¯è§‚æµ‹æ€§çš„ä¸‰å¤§æ”¯æŸ± æ—¥å¿—Log ç”¨äºå›æº¯å’Œè°ƒè¯•ï¼Œç•¥ã€‚\næŒ‡æ ‡Metrics Metrics æ˜¯ç³»ç»Ÿè¿è¡ŒçŠ¶æ€çš„é‡åŒ–æ•°æ®ï¼Œé€šå¸¸æ˜¯éšæ—¶é—´å˜åŒ–çš„æ•°å€¼ã€‚æ¯”å¦‚ï¼š\næ¯ç§’å¤„ç†çš„è¯·æ±‚æ•°ï¼ˆQPSï¼‰ è¯·æ±‚å¹³å‡è€—æ—¶ï¼ˆRTï¼‰ æœåŠ¡å™¨CPUä½¿ç”¨ç‡ é”™è¯¯è¯·æ±‚çš„æ¯”ä¾‹ è¿½è¸ªTraces Traces ç”¨äºè®°å½•ä¸€ä¸ªè¯·æ±‚åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„å®Œæ•´æ‰§è¡Œè·¯å¾„ã€‚æƒ³è±¡ç”¨æˆ·ä¸€æ¬¡ç‚¹å‡»ï¼Œå¯èƒ½ç»è¿‡ç½‘å…³â†’è®¢å•æœåŠ¡â†’åº“å­˜æœåŠ¡â†’æ”¯ä»˜æœåŠ¡â†’æ•°æ®åº“ã€‚Traces èƒ½å®Œæ•´è¿˜åŸè¿™ä¸ªé“¾æ¡ä¸­æ¯ä¸€æ­¥å‘ç”Ÿäº†ä»€ä¹ˆã€èŠ±äº†å¤šä¹…ã€‚\næ ¸å¿ƒæ¦‚å¿µï¼šSpanï¼ˆè·¨åº¦ï¼‰ æ¯ä¸ªæœåŠ¡å¤„ç†è¯·æ±‚çš„è¿‡ç¨‹è¢«è®°å½•ä¸ºä¸€ä¸ª Spanï¼ŒåŒ…å«ï¼š\næ“ä½œåï¼ˆå¦‚createOrderï¼‰ å¼€å§‹/ç»“æŸæ—¶é—´æˆ³ å…³é”®å±æ€§ï¼ˆHTTPçŠ¶æ€ç ã€DBæŸ¥è¯¢è¯­å¥ï¼‰ çˆ¶å­å…³ç³»ï¼ˆå“ªä¸ªæœåŠ¡è°ƒç”¨äº†å“ªä¸ªæœåŠ¡ï¼‰ Trace IDï¼šè´¯ç©¿å…¨é“¾è·¯çš„å”¯ä¸€æ ‡è¯†ï¼Œç”¨äºä¸²è”æ‰€æœ‰Span å·¥å…·è§£é‡Š Micrometer æ ¸å¿ƒä½œç”¨ï¼š Micrometer æ˜¯ â€‹â€‹Java åº”ç”¨çš„æŒ‡æ ‡åŸ‹ç‚¹é—¨é¢åº“â€‹â€‹ï¼Œæä¾›ç»Ÿä¸€ APIï¼ˆå¦‚è®¡æ•°å™¨ã€è®¡æ—¶å™¨ï¼‰ï¼Œè®©å¼€å‘è€…æ— éœ€å…³å¿ƒåç«¯ç›‘æ§ç³»ç»Ÿï¼ˆPrometheusã€Datadog ç­‰ï¼‰ã€‚\næ•°æ®æµå‘ï¼š åº”ç”¨ä»£ç åŸ‹ç‚¹ â†’ Micrometer ç”ŸæˆæŒ‡æ ‡æ•°æ® â†’ ç›´æ¥è¾“å‡ºç»™ Prometheusã€‚\nç¤ºä¾‹åœºæ™¯ï¼š åœ¨ Spring Boot ä¸­é…ç½® Micrometer çš„ Prometheus å¯¼å‡ºå™¨ï¼ŒæŒ‡æ ‡ä¼šé€šè¿‡ /actuator/prometheus ç«¯ç‚¹æš´éœ²ï¼Œä¾› Prometheus æ‹‰å–ã€‚\nOpenTelemetryï¼ˆOTelï¼‰ OTelæ˜¯è·¨è¯­è¨€çš„å¯è§‚æµ‹æ•°æ®é‡‡é›†æ¡†æ¶ï¼Œç»Ÿä¸€å¤„ç† Metricsã€Tracesã€Logs çš„ç”Ÿæˆã€è½¬æ¢å’Œå¯¼å‡ºã€‚\nä¸Micrometerçš„å…³ç³»ï¼šOTel SDKå¯ä»¥åŒ…è£…Micrometeræ³¨å†Œçš„ MeterRegistry ï¼Œå°†æ•°æ®é€šè¿‡OTLPåè®®å¯¼å‡ºã€‚\nTracesåœºæ™¯ä¸‹ï¼š\nOTelæ˜¯Trace æ•°æ®çš„ä¸»è¦é‡‡é›†å™¨ï¼Œå¯å°†Traceæ•°æ®å‘ç»™SkyWalkingã€Jaegerç­‰ã€‚\nPrometheus æ ¸å¿ƒä½œç”¨ï¼š ä¸“æ³¨ â€‹â€‹æŒ‡æ ‡ï¼ˆMetricsï¼‰çš„å­˜å‚¨ã€æŸ¥è¯¢å’Œå‘Šè­¦â€‹â€‹ï¼Œä¸å¤„ç† Trace æ•°æ®ã€‚\nä¸ Micrometer åä½œï¼š Micrometer å°†æŒ‡æ ‡æš´éœ²ä¸º Prometheus æ ¼å¼ â†’ Prometheus å®šæ—¶æ‹‰å–å¹¶å­˜å‚¨ â†’ Grafana å¯è§†åŒ–\nSkyWalking å®šä½ï¼šå¼€æºAPM (Application Performance Management) ç³»ç»Ÿï¼Œä¸“æ³¨äºå…¨é“¾è·¯è¿½è¸ªï¼ˆTracingï¼‰ å’Œæ‹“æ‰‘åˆ†æã€‚\næ ¸å¿ƒèƒ½åŠ›ï¼š\n**è°ƒç”¨é“¾è¿½è¸ªï¼š**è®°å½•è¯·æ±‚è·¨æœåŠ¡çš„å®Œæ•´è·¯å¾„ï¼Œå¯è§†åŒ–æ¯ä¸ªç¯èŠ‚è€—æ—¶ä¸çŠ¶æ€ï¼ˆSpan æ•°æ®ï¼‰ã€‚ æœåŠ¡æ‹“æ‰‘ï¼šè‡ªåŠ¨ç»˜åˆ¶æœåŠ¡ä¾èµ–å…³ç³»å›¾ï¼Œå¿«é€Ÿå®šä½ç“¶é¢ˆèŠ‚ç‚¹ã€‚ æŒ‡æ ‡é›†æˆï¼šæ”¯æŒåŸºç¡€èµ„æºï¼ˆJVM/çº¿ç¨‹æ± ï¼‰å’Œé“¾è·¯æŒ‡æ ‡ï¼ˆæ…¢è¯·æ±‚æ¯”ä¾‹ï¼‰ã€‚ OTLPåè®® OTLPï¼ˆOpenTelemetry Protocolï¼‰æ˜¯OpenTelemetryé¡¹ç›®å®šä¹‰çš„æ ‡å‡†æ•°æ®ä¼ è¾“åè®®ï¼Œç”¨äºåœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­é«˜æ•ˆã€å¯é åœ°ä¼ è¾“é¥æµ‹æ•°æ®ï¼ˆåŒ…æ‹¬è¿½è¸ªä¿¡æ¯ã€æŒ‡æ ‡å’Œæ—¥å¿—ï¼‰ã€‚\nä¼ è¾“æ–¹å¼ åè®® é»˜è®¤ç«¯å£ é€‚ç”¨åœºæ™¯ OTLP/gRPC gRPC + Protobuf 4317 é«˜æ€§èƒ½å†…éƒ¨é€šä¿¡ï¼ˆå¦‚åº”ç”¨â†’æ”¶é›†å™¨ï¼‰ OTLP/HTTP HTTP/1.1æˆ–HTTP/2 + Protobuf/JSON 4318 ç©¿é€é˜²ç«å¢™æˆ–å…¼å®¹HTTPçš„ç¯å¢ƒ æ•°æ®è·¯å¾„ï¼š\nåº”ç”¨ â†’ï¼ˆOTLP/gRPCï¼‰â†’ OpenTelemetry Collector â†’ï¼ˆè½¬æ¢æ ¼å¼ï¼‰â†’ Prometheus/Jaegerã€‚\né˜¿é‡Œäº‘ARMS å®šä½ï¼šä¼ä¸šçº§å…¨æ ˆç›‘æ§äº§å“ï¼Œæ•´åˆæ—¥å¿—ã€æŒ‡æ ‡ã€è¿½è¸ªèƒ½åŠ›ã€‚\nå…¼å®¹ OpenTelemetryã€SkyWalking ç­‰å¼€æºåè®®ã€‚\nMicrometerå’ŒOTelé›†æˆ Springbootå¯¹äºMicrometerå’ŒOTelçš„é›†æˆåšçš„è¾ƒå¥½ï¼Œæˆ‘ä»¬ä¸»è¦å…³æ³¨Micrometerçš„é‡‡é›†å³å¯ã€‚\nMicrometeræœ€ä½³å®è·µ Micrometer Observation APIçš„å®˜æ–¹æ¨èæ¶æ„æ¨¡å¼ï¼š\nğŸ“‹ Documentation (æ–‡æ¡£å®šä¹‰) â†“ å®šä¹‰æ ‡å‡†\nğŸ›ï¸ Convention (çº¦å®šå®ç°) â†“ å¤„ç†è§„åˆ™\nğŸ“¦ Context (ä¸Šä¸‹æ–‡æ•°æ®) â†“ æ•°æ®è½½ä½“\nğŸ”§ Handler (å¤„ç†å™¨æ‰§è¡Œ) â†“ å®é™…å¤„ç†\nğŸ“Š Metrics \u0026amp; Logs (è¾“å‡ºç»“æœ)\nContext æ˜¯å®é™…è§‚æµ‹æ•°æ®çš„è½½ä½“ï¼Œå­˜å‚¨éœ€è¦è§‚æµ‹çš„æ‰€æœ‰ä¿¡æ¯ã€‚ä»¥GraphObservationå®ç°ä¸ºä¾‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 public class GraphNodeObservationContext extends Observation.Context { private final String nodeName; // èŠ‚ç‚¹åç§° private final String event; // äº‹ä»¶ç±»å‹ (onStart/before/after/onError/onComplete) private final Map\u0026lt;String, Object\u0026gt; state; // èŠ‚ç‚¹çŠ¶æ€ private final Map\u0026lt;String, Object\u0026gt; output; // èŠ‚ç‚¹è¾“å‡º // æ„é€ å‡½æ•° + Getteræ–¹æ³• + Builderæ¨¡å¼ public static Builder builder() { return new Builder(); } } Documentation æ˜¯åˆ¶å®šçš„è§‚æµ‹æ ‡å‡†ï¼Œçº¦å®šè§‚æµ‹çš„æ ‡ç­¾ã€æŒ‡æ ‡åç§°ç­‰ï¼ŒåŒæ—¶åˆ†ç±»é«˜ä½åŸºæ•°æ ‡ç­¾ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public enum GraphNodeObservationDocumentation implements ObservationDocumentation { GRAPH_NODE { @Override public Class\u0026lt;? extends ObservationConvention\u0026lt;? extends Context\u0026gt;\u0026gt; getDefaultConvention() { return GraphNodeObservationConvention.class; // ğŸ‘ˆ æŒ‡å®šçº¦å®šç±» } @Override public KeyName[] getLowCardinalityKeyNames() { return LowCardinalityKeyNames.values(); // ğŸ‘ˆ ä½åŸºæ•°æ ‡ç­¾ } @Override public KeyName[] getHighCardinalityKeyNames() { return HighCardinalityKeyNames.values(); // ğŸ‘ˆ é«˜åŸºæ•°æ ‡ç­¾ } }; // ä½åŸºæ•°æ ‡ç­¾å®šä¹‰ (é€‚åˆèšåˆæŸ¥è¯¢) public enum LowCardinalityKeyNames implements KeyName { SPRING_AI_ALIBABA_KIND, // spring.ai.alibaba.kind GRAPH_NODE_NAME, // spring.ai.alibaba.graph.node.name GRAPH_EVENT // spring.ai.alibaba.graph.event } // é«˜åŸºæ•°æ ‡ç­¾å®šä¹‰ (è¯¦ç»†ä¿¡æ¯) public enum HighCardinalityKeyNames implements KeyName { GRAPH_NODE_STATE, // spring.ai.alibaba.graph.node.state GRAPH_NODE_OUTPUT // spring.ai.alibaba.graph.node.output } } Convention å¤„ç†Documentationï¼Œåˆ†ç¦»é«˜ä½åŸºæ•°æ ‡ç­¾ï¼Œå°†Contextæ•°æ®è½¬æ¢ä¸ºè§‚æµ‹æ ‡ç­¾ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class DefaultGraphNodeObservationConvention implements GraphNodeObservationConvention { @Override public String getName() { return \u0026#34;spring.ai.alibaba.graph.node\u0026#34;; // ğŸ‘ˆ è§‚æµ‹åç§° } @Override public String getContextualName(GraphNodeObservationContext context) { if (StringUtils.hasText(context.getName())) { return \u0026#34;%s %s\u0026#34;.formatted(DEFAULT_OPERATION_NAME, context.getName()); } return DEFAULT_OPERATION_NAME; // ğŸ‘ˆ ä¸Šä¸‹æ–‡åç§°ç”Ÿæˆ } @Override public KeyValues getLowCardinalityKeyValues(GraphNodeObservationContext context) { return KeyValues.of( KeyValue.of(\u0026#34;spring.ai.alibaba.kind\u0026#34;, \u0026#34;graph_node\u0026#34;), KeyValue.of(\u0026#34;spring.ai.alibaba.graph.node.name\u0026#34;, context.getNodeName()), KeyValue.of(\u0026#34;spring.ai.alibaba.graph.event\u0026#34;, context.getEvent()) ); // ğŸ‘ˆ ä½åŸºæ•°æ ‡ç­¾ç”Ÿæˆ } @Override public KeyValues getHighCardinalityKeyValues(GraphNodeObservationContext context) { return KeyValues.of( KeyValue.of(\u0026#34;spring.ai.alibaba.graph.node.state\u0026#34;, context.getState().toString()), KeyValue.of(\u0026#34;spring.ai.alibaba.graph.node.output\u0026#34;, context.getOutput().toString()) ); // ğŸ‘ˆ é«˜åŸºæ•°æ ‡ç­¾ç”Ÿæˆ } } Handler å¤„ç†è§‚æµ‹çš„äº‹ä»¶ï¼Œå…·ä½“ä½œç”¨å‚è§ç»„ä»¶åä½œæµç¨‹ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class GraphNodeObservationHandler implements ObservationHandler\u0026lt;GraphNodeObservationContext\u0026gt; { private final MeterRegistry meterRegistry; @Override public void onStop(GraphNodeObservationContext context) { // 1. è®°å½•æˆåŠŸæ—¥å¿— logger.info(\u0026#34;Graph nodeName: {} event: {} state: {} output: {}\u0026#34;, context.getNodeName(), context.getEvent(), context.getState(), context.getOutput()); // 2. ç”ŸæˆæˆåŠŸæŒ‡æ ‡ GraphMetricsGenerator.generate(context, meterRegistry, true); } @Override public void onError(GraphNodeObservationContext context) { // 1. è®°å½•é”™è¯¯æ—¥å¿— logger.error(\u0026#34;Graph nodeName: {} event: {} state: {} output: {}\u0026#34;, ...); // 2. ç”Ÿæˆå¤±è´¥æŒ‡æ ‡ GraphMetricsGenerator.generate(context, meterRegistry, false); } @Override public boolean supportsContext(Observation.Context context) { return context instanceof GraphNodeObservationContext; // ğŸ‘ˆ æ”¯æŒç±»å‹åˆ¤æ–­ } } ç»„ä»¶åä½œæµç¨‹ å½“åˆ›å»ºä¸€ä¸ªè§‚æµ‹æ—¶ï¼š\n1 2 3 4 // 1. åˆ›å»ºè§‚æµ‹æ—¶ Observation.start(GraphObservationDocumentation.GRAPH.getName(), () -\u0026gt; new GraphObservationContext(nodeId, state, null), observationRegistry) ä¼šå‘ç”Ÿä»¥ä¸‹æ­¥éª¤ï¼š\né¦–å…ˆæ ¹æ®Observationä¼ å…¥çš„Conventionå°†Contexté‡Œé¢çš„æ•°æ®è½¬æ¢æˆKeyValueå¯¹ï¼ˆå…¶ä¸­Conventionä¼šä»å¯¹åº”çš„Documentationé‡Œé¢å»æ‰¾é«˜ä½åŸºæ•°é”®å’Œåå­—ï¼‰ Conventionçš„åº”ç”¨åœ¨Handlerè¢«è°ƒç”¨ä¹‹å‰ï¼Œä»–ä¼šç»™Observation.ContextåŸºç±»ä¸­æ·»åŠ Conventionæ ‡å‡†åŒ–åçš„KeyValueï¼Œç„¶åè¿™ä¸ªContextä¼šè¢«åç»­çš„Handleræ‰€ä½¿ç”¨ ç„¶åè¢«æ³¨å†Œåˆ°ObservationRegé‡Œé¢çš„Handlerï¼Œä¼šä½¿ç”¨MetricsGeneratorå»åˆ›å»ºMetricsï¼ŒåŒæ—¶Metricsä¼šæ³¨å†Œåˆ°meterRegé‡Œé¢ MetircsGeneratorä¼šåˆ›å»ºæ‰€éœ€è¦çš„Tagï¼ŒåŒ…æ‹¬ç›´æ¥åˆ›å»ºçš„å’Œè¢«KeyValueä¸­çš„Keyæ‰€è½¬æ¢çš„ã€‚ ObservationRegçš„ä½œç”¨ ä½œç”¨å’ŒèŒè´£ï¼š\nHandler ç®¡ç†ï¼šæ³¨å†Œå’Œç®¡ç† ObservationHandler Convention ç®¡ç†ï¼šç®¡ç†è§‚æµ‹çº¦å®šï¼ˆå¦‚ä½•è½¬æ¢Contextä¸ºæ ‡ç­¾ï¼‰ Filter ç®¡ç†ï¼šç®¡ç†è§‚æµ‹è¿‡æ»¤å™¨ è§‚æµ‹ç”Ÿå‘½å‘¨æœŸæ§åˆ¶ï¼šåè°ƒè§‚æµ‹çš„åˆ›å»ºã€å¯åŠ¨ã€åœæ­¢ MeterRegçš„ä½œç”¨ ä½œç”¨å’ŒèŒè´£ï¼š\næŒ‡æ ‡ç®¡ç†ä¸­å¿ƒï¼šåˆ›å»ºã€æ³¨å†Œå’Œç®¡ç†æ‰€æœ‰çš„æŒ‡æ ‡å¯¹è±¡ï¼ˆCounterã€Timerã€Gaugeç­‰ï¼‰ æŒ‡æ ‡æ•°æ®å­˜å‚¨ï¼šåœ¨å†…å­˜ä¸­ç»´æŠ¤æŒ‡æ ‡çš„å½“å‰å€¼ æŒ‡æ ‡æ•°æ®å‘å¸ƒï¼šå°†æ”¶é›†çš„æŒ‡æ ‡æ•°æ®å‘å¸ƒåˆ°å„ç§ç›‘æ§ç³»ç»Ÿ Traceç›¸å…³ åˆšåˆšçš„æœ€ä½³å®è·µä»…ä»…è½è„šåœ¨metricsï¼Œå…³äºtraceï¼Œå¹¶æ²¡æœ‰è¯´æ˜ã€‚\nåœ¨SpringBootä¸­ï¼Œå½“æœ‰Micrometer Tracingæ¡¥æ¥åº“æ—¶å€™ï¼Œè‡ªåŠ¨é…ç½®ä¼šç”Ÿæ•ˆï¼Œé…ç½®TracingObservationHandlerä»¥åŠç›¸å…³ç»„ä»¶ã€‚\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.micrometer\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;micrometer-tracing-bridge-otel\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; TracingObservationHandler ä¼šè¢«è‡ªåŠ¨æ³¨å†Œåˆ° ObservationRegistry ä¸­ï¼Œç›‘å¬ startã€stopã€error ç­‰äº‹ä»¶ï¼Œç”Ÿæˆå¯¹åº”çš„ Span æ•°æ®ã€‚\nåŸºæœ¬æ¦‚å¿µçš„åŒºåˆ† Tagå’ŒMetricsçš„å…³ç³» Tagæ˜¯Metricsçš„ç»„æˆéƒ¨åˆ†ï¼Œä¸€ä¸ªå®Œæ•´çš„Metricç”±name + tags + valueç»„æˆã€‚\n1 2 3 4 5 6 7 // ä¸€ä¸ªå®Œæ•´çš„Metricç”± name + tags + value ç»„æˆ Counter.builder(\u0026#34;api.requests\u0026#34;) // â† Metricåç§° .tag(\u0026#34;method\u0026#34;, \u0026#34;GET\u0026#34;) // â† Tag 1 .tag(\u0026#34;status\u0026#34;, \u0026#34;200\u0026#34;) // â† Tag 2 .tag(\u0026#34;endpoint\u0026#34;, \u0026#34;/users\u0026#34;) // â† Tag 3 .register(registry) .increment(); // â† å€¼çš„æ“ä½œ åŒæ—¶ï¼ŒTagå¯ä»¥ä¸ºMetricæä¾›èšåˆèƒ½åŠ›ï¼Œæ¯”å¦‚å¯ä»¥ç­›é€‰å‡ºTag=ç‰¹å®šå€¼çš„Metricä¸ªæ•°ã€‚\nèšåˆä»¥åçš„Metricsï¼Œä¹Ÿå¯ä»¥å«åšMetricï¼Œæ›´ç²¾å‡†çš„å«æ³•æ˜¯Calculated Metricã€‚\nTagçš„åŸºæ•° é«˜ä½åŸºæ•°æ˜¯Tagçš„åˆ†ç±»ä¾æ®ï¼ŒåŸºæ•°æ˜¯ä»€ä¹ˆæ„æ€å‘¢ï¼Œå°±æ˜¯è¯´Tagçš„å¯èƒ½å€¼ã€‚æ¯”å¦‚Tagçš„keyæ˜¯ç”¨æˆ·ç”¨æ—¶ï¼Œé‚£ä¹ˆå¯èƒ½çš„valueå°±ä¼šéå¸¸å¤šï¼Œå°±æ˜¯é«˜åŸºæ•°Tagã€‚åä¹‹ï¼ŒTagçš„keyå¯èƒ½æ˜¯RESTful APIçš„methodï¼Œé‚£ä¸€å…±å°±é‚£ä¹ˆå‡ ç§ï¼Œå°±æ˜¯ä½åŸºæ•°Tagã€‚\nSpanå’ŒMetricsçš„å…³ç³» 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Metric ç¤ºä¾‹ï¼šèšåˆç»Ÿè®¡ Counter.builder(\u0026#34;http.requests.total\u0026#34;) .tag(\u0026#34;method\u0026#34;, \u0026#34;GET\u0026#34;) .tag(\u0026#34;status\u0026#34;, \u0026#34;200\u0026#34;) .register(registry) .increment(); // ç»“æœï¼šhttp_requests_total{method=\u0026#34;GET\u0026#34;,status=\u0026#34;200\u0026#34;} 1500 // Span ç¤ºä¾‹ï¼šå•ä¸ªè¯·æ±‚è¯¦æƒ… Span span = tracer.spanBuilder(\u0026#34;http-request\u0026#34;) .setAttribute(\u0026#34;http.method\u0026#34;, \u0026#34;GET\u0026#34;) .setAttribute(\u0026#34;http.url\u0026#34;, \u0026#34;/api/users/12345\u0026#34;) .setAttribute(\u0026#34;http.status_code\u0026#34;, 200) .setAttribute(\u0026#34;user.id\u0026#34;, \u0026#34;12345\u0026#34;) .setAttribute(\u0026#34;response.size\u0026#34;, 2048) .startSpan(); å¯¹æ¯”æ¥çœ‹ï¼ŒSpanæ˜¯å¾®è§‚è§†å›¾ï¼ŒMetricæ˜¯å®è§‚è§†å›¾ã€‚\nTraceå’ŒSpançš„å…³ç³» Traceçš„åŸºæœ¬å•ä½æ˜¯ä¸€ä¸ªä¸€ä¸ªçš„spanï¼Œå¤šä¸ªspané€šè¿‡parent-childå…³ç³»ç»„æˆå®Œæ•´çš„Traceã€‚\næ¯ä¸ªspanåŒ…å«ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;traceId\u0026#34;: \u0026#34;c227f936a3eb510e7da12fda10a8ffab\u0026#34;, \u0026#34;spanId\u0026#34;: \u0026#34;884c2f1abf7f956b\u0026#34;, \u0026#34;parentSpanId\u0026#34;: \u0026#34;293e5b7de78ff24c\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;chat qwen-max\u0026#34;, \u0026#34;kind\u0026#34;: 1, \u0026#34;startTimeUnixNano\u0026#34;: \u0026#34;1733482368328941400\u0026#34;, \u0026#34;endTimeUnixNano\u0026#34;: \u0026#34;1733482372190192300\u0026#34;, \u0026#34;attributes\u0026#34;: [...], \u0026#34;events\u0026#34;: [...], \u0026#34;status\u0026#34;: {...} } Spançš„ä¸Šä¼ æ—¶æœº è‡ªåŠ¨ä¸Šä¼ æ—¶æœºï¼š\nSpanå®Œæˆæ—¶ï¼šå½“ä¸€ä¸ªæ“ä½œç»“æŸï¼Œå¯¹åº”çš„spanä¼šè‡ªåŠ¨ç»“æŸå¹¶è§¦å‘ä¸Šä¼ \nç¼“å†²åŒºæ»¡æ—¶ï¼šå½“å†…å­˜ä¸­ç§¯ç´¯çš„spanæ•°æ®è¾¾åˆ°ä¸€å®šå¤§å°ï¼ˆå¦‚1MBï¼‰æ—¶æ‰¹é‡ä¸Šä¼ \nå®šæ—¶ä¸Šä¼ ï¼šOpenTelemetry SDKä¼šå®šæœŸflushæœªä¸Šä¼ çš„span\nåº”ç”¨å…³é—­æ—¶ï¼šé€šè¿‡shutdown()æ–¹æ³•ç¡®ä¿æ‰€æœ‰spanéƒ½è¢«ä¸Šä¼ \næ‰‹åŠ¨ä¸Šä¼ æ—¶æœºï¼š\nè°ƒç”¨flush()ï¼šå¯ä»¥æ‰‹åŠ¨è§¦å‘spanä¸Šä¼ \nåº”ç”¨é‡å¯å‰ï¼šç¡®ä¿æ•°æ®ä¸ä¸¢å¤±\nspanç»“æŸåçš„ä¸Šä¼ ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Override public CompletableResultCode export(Collection\u0026lt;SpanData\u0026gt; spans) { if (!studioObservabilityProperties.isEnabled()) { return CompletableResultCode.ofSuccess(); } if (isShutdown.get()) { return CompletableResultCode.ofFailure(); } // ç«‹å³å¤„ç†spanæ•°æ® ResourceSpansMarshaler[] allResourceSpans = ResourceSpansMarshaler.create(spans); return studioObservabilityService.export(List.of(allResourceSpans)); } åˆ°è¾¾é˜ˆå€¼åæ‰¹é‡ä¸Šä¼ ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 try (BufferedWriter writer = Files.newBufferedWriter(outputPath, StandardOpenOption.APPEND)) { StringBuilder sb = new StringBuilder(); for (ResourceSpansMarshaler resourceSpans : allResourceSpans) { String json = generateJson(resourceSpans); sb.append(json).append(LINE_SEPARATOR); // å½“ç¼“å­˜è¾¾åˆ°1MBæ—¶æ‰¹é‡å†™å…¥ if (sb.length() \u0026gt; 1024 * 1024) { writer.write(sb.toString()); sb.setLength(0); } } if (!sb.isEmpty()) { writer.write(sb.toString()); } } Spring AIé€šè¿‡OTelä¸Langfuseé›†æˆ Spring AIå®ç°äº†åŸºäºmicrometerçš„åŸ‹ç‚¹ï¼Œå¯ä»¥è½»æ¾çš„ä½¿ç”¨OTLPåè®®å¯¼å‡ºï¼Œè¿›è€Œå®ç°è§‚æµ‹æ•°æ®ä¸Šä¼ è‡³Langfuseã€‚\nå¼•å…¥ä¾èµ– 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud.ai\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-ai-alibaba-starter-dashscope\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.ai\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-ai-autoconfigure-model-chat-observation\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.ai\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-ai-autoconfigure-model-embedding-observation\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.ai\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-ai-autoconfigure-model-image-observation\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.ai\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-ai-autoconfigure-vector-store-observation\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.ai\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-ai-vector-store\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud.ai\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-ai-alibaba-starter-tool-calling-weather\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.opentelemetry.instrumentation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;opentelemetry-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.micrometer\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;micrometer-tracing-bridge-otel\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-api\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.opentelemetry\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;opentelemetry-exporter-otlp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; é…ç½®LangFuse æ³¨å†Œè´¦å·ã€è·å–API Keyï¼š\nhttps://cloud.langfuse.com\nLinux/MacOSï¼š\n1 echo -n \u0026#34;public_key:secret_key\u0026#34; | base64 Windows PowerShellï¼š\n1 [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes(\u0026#34;public_key:secret_key\u0026#34;)) é…ç½®application.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 spring: application: name: observability-models-dashscope ai: dashscope: api-key: ${AI_DASHSCOPE_API_KEY} # spring ai alibaba weather tool calling config alibaba: toolcalling: weather: api-key: ${WEATHER_API_KEY} enabled: true # Chat config items chat: client: observations: # default value is false. log-prompt: true observations: log-prompt: true log-completion: true include-error-logging: true # vector store config items vectorstore: observations: log-query-response: true # tools config items tools: observations: # default value is false. include-content: true image: observations: log-prompt: true http: client: read-timeout: 60s management: endpoints: web: exposure: include: \u0026#34;*\u0026#34; endpoint: health: # health status check with detailed messages show-details: always tracing: sampling: # trace information with every request probability: 1.0 observations: annotations: enabled: true otel: service: name: spring-ai-alibaba-graph-langfuse resource: attributes: deployment.environment: development # configure exporter traces: exporter: otlp sampler: always_on metrics: exporter: otlp # logs exportation inhibited for langfuse currently cannot support logs: exporter: none exporter: otlp: endpoint: \u0026#34;https://cloud.langfuse.com/api/public/otel\u0026#34; headers: Authorization: \u0026#34;Basic ${YOUR_BASE64_ENCODED_CREDENTIALS}\u0026#34; protocol: http/protobuf ","date":"2025-06-25T00:00:00Z","permalink":"https://sixiyida.github.io/p/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7observation%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"å¯è§‚æµ‹æ€§Observationå­¦ä¹ ç¬”è®°"},{"content":"\nList ArrayList LinkedList Vector CopyOnWriteArrayList ç±»ä¼¼C++çš„Vectorï¼Œç•¥ ç±»ä¼¼C++çš„Listï¼Œç•¥ åŒæ­¥ArrayList å†™æ—¶å¤åˆ¶ï¼Œè¯»æ— é”ï¼Œæå‡å¹¶å‘æ€§èƒ½ éå†æ—¶ä¿®æ”¹ ç”¨foreachä¸èƒ½ä¿®æ”¹ï¼Œå®¹æ˜“å‡ºç°é—®é¢˜ã€‚\nç”¨è¿­ä»£å™¨/foréå†ï¼Œå¯ä»¥ä¿®æ”¹ï¼Œè¿­ä»£å™¨ä¿®æ”¹è¦ä½¿ç”¨è¿­ä»£å™¨çš„setæ–¹æ³•ã€‚\nå¯¹COWAï¼Œå¯ä»¥ä¿®æ”¹ï¼Œå› ä¸ºåœ¨å‰¯æœ¬ä¸Šä¿®æ”¹ã€‚\nArrayListå¤šçº¿ç¨‹è®¿é—®ä¸‹å¯èƒ½å‡ºç°çš„é—®é¢˜ ä»¥å¤šçº¿ç¨‹addå…ƒç´ ä¸ºä¾‹ã€‚\nç«äº‰æ‰©å®¹å¯¼è‡´éƒ¨åˆ†å€¼è®¾ç½®ä¸ºnullã€‚ ç«äº‰å¯¼è‡´ä¸æ‰©å®¹ï¼Œå¯¼è‡´è¶Šç•Œè®¿é—®ã€‚ è¦†ç›–åŒä¸€ä½ç½®çš„å€¼ã€‚ æ‰©å®¹æ“ä½œ ç±»ä¼¼C++ä¸­Vectorï¼Œåªæ˜¯åœ¨Javaä¸­æ‰©å®¹å€æ•°æ˜¯1.5å€ï¼Œè€ŒVectoræ˜¯ä¸¤å€ã€‚\nCOAWçš„çº¿ç¨‹å®‰å…¨ è¯»æ—¶æ— é”ï¼Œå†™æ—¶è·å–äº’æ–¥é”å¹¶å¤åˆ¶ã€‚\nMAP HashMap LinkedHashMap TreeMap HashTable ConcurrentHashMap unordered_map + çº¢é»‘æ ‘é“¾åœ°å€æ³• åŒå‘é“¾è¡¨ç»´æŠ¤åº•å±‚ï¼Œè¿­ä»£é¡ºåºå’Œæ’å…¥é¡ºåºä¸€è‡´ã€‚ map åŠ å¤§é”çš„HashMap å…ƒç´ çº§é”çš„HashMap éå†æ–¹æ³• For-each+entrySet/keySet è¿­ä»£å™¨ foreachæ–¹æ³• StreamAPI HashMapç«äº‰é—®é¢˜ JDK1.7ä¹‹å‰ Entryæ•£é“¾æ­»å¾ªç¯é—®é¢˜ï¼š\nç”±äºå¤´æ’æ³•ï¼ˆåœ¨é“¾è¡¨å¤´éƒ¨æ’å…¥ï¼‰ï¼Œå½“çº¿ç¨‹T1ã€T2åŒæ—¶æ‰©å®¹æ—¶ï¼Œå¯èƒ½ä¼šå‡ºç°ä»¥ä¸‹æƒ…å†µï¼š\nT2æ‰©å®¹ååè½¬é“¾è¡¨ä¸ºB-\u0026gt;Aï¼Œä½†æ˜¯T1ä»ç„¶æ“çºµæ—§é“¾è¡¨çš„å¤´èŠ‚ç‚¹Aï¼Œä¸”è®¤ä¸ºAçš„nextæ˜¯Bï¼Œå¯¼è‡´ABä¹‹é—´ç›¸äº’æŒ‡å‘ã€‚\næ•°æ®ä¸¢å¤±é—®é¢˜ï¼š\nç±»ä¼¼äºListçš„æ‰©å®¹nullé—®é¢˜ã€‚\nJDK1.8ä¹‹å æ•£é“¾æ”¹æˆäº†çº¢é»‘æ ‘ç»“æ„ï¼Œåªå­˜åœ¨æ•°æ®è¦†ç›–é—®é¢˜ã€‚ Putæµç¨‹ å‰é¢hash-\u0026gt;CASè·³è¿‡ï¼Œåç»­æ˜¯ï¼šæ£€æŸ¥æ•£é“¾å¤§å°ï¼ˆ8ï¼‰-\u0026gt;è½¬çº¢é»‘æ ‘ï¼Ÿ-\u0026gt;æ£€æŸ¥è´Ÿè½½å› å­-\u0026gt;æ‰©å®¹ä¸¤å€ï¼Ÿ\næ³¨æ„ï¼škeyå¯ä»¥ä¸ºnullï¼Œå½“ä¸ºnullæ—¶å€™ä»¤hashCodeä¸º0\nHashMapç”¨StringåšKeyçš„åŸå›  Stringä¸å¯å˜ï¼Œä¿è¯Keyç¨³å®šæ€§ã€‚\nå¯¹é‡å†™hashCode()å’Œequals()çš„é™åˆ¶ equalsæ˜¯hashCodeç›¸ç­‰çš„å……åˆ†ä¸å¿…è¦æ¡ä»¶ã€‚\nHashMapæ‰©å®¹æ˜¯ä¸¤å€çš„åŸå›  æ–°hashå€¼=æ—§å“ˆå¸Œå€¼+æ–°hashå€¼æœ€é«˜ä½ä»£è¡¨æ•°å€¼ï¼ˆ0æˆ–è€…æ˜¯æ—§å®¹é‡ï¼‰ã€‚\nConcurrentHashMapåŸç† 1.8ä»¥åï¼šå½“å®¹å™¨ä¸ºç©º/æ•£é“¾ä¸ºç©ºï¼Œç”¨CASåˆå§‹åŒ–ï¼›å½“ä¸ä¸ºç©ºï¼Œå¯¹æ•£é“¾å¤´èŠ‚ç‚¹åŠ äº’æ–¥é”ï¼Œé”ç²’åº¦å‡å°ï¼Œå¹¶å‘é‡ä¸Šå‡ã€‚\n","date":"2025-06-24T00:00:00Z","permalink":"https://sixiyida.github.io/p/%E5%85%AB%E8%82%A1%E6%96%87%E4%B9%8Bjava%E9%9B%86%E5%90%88/","title":"å…«è‚¡æ–‡ä¹‹Javaé›†åˆ"},{"content":"æ·±æ‹·è´çš„ä¸‰ç§æ–¹æ³• å®ç°cloneæ¥å£ï¼Œè¦æ±‚å¼•ç”¨å±æ€§å…¨éƒ¨å®ç°clonableæ¥å£ï¼Œé€’å½’è°ƒç”¨ã€‚ ç›´æ¥åºåˆ—åŒ–ç„¶åååºåˆ—åŒ–ï¼Œè¦æ±‚å¼•ç”¨å±æ€§å…¨éƒ¨å®ç°serializableæ¥å£ã€‚ æ‰‹åŠ¨é€’å½’å¤åˆ¶ã€‚ åå°„çš„åº”ç”¨åœºæ™¯ åŠ è½½æ•°æ®åº“é©±åŠ¨ï¼ŒåŠ¨æ€åŠ è½½é©±åŠ¨ç±»ã€‚ IOCå®¹å™¨è‡ªåŠ¨è£…é…ï¼Œæ ¹æ®ç±»ååŠ¨æ€åŠ è½½å®ä¾‹ã€‚ï¼ˆè¿™ä¸ªåœ¨springå…«è‚¡é‡Œé¢ç»†è¯´ï¼‰ æ³¨è§£ æœ¬è´¨ä¸Šæ˜¯ä¸€ç§ç»§æ‰¿è‡ªAnnotationçš„ç‰¹æ®Šæ¥å£ï¼Œåœ¨å®šä¹‰æ³¨è§£æ—¶å€™ï¼Œç¼–è¯‘å™¨ä¼šå°†å…¶è½¬æ¢ä¸ºæ¥å£å¹¶ç”Ÿæˆå­—èŠ‚ç ã€‚\næ ¹æ®ä½œç”¨èŒƒå›´åˆ†ç±»ï¼š\næºç çº§åˆ«æ³¨è§£ ç±»æ–‡ä»¶çº§åˆ«æ³¨è§£ï¼ˆåœ¨.classä¸­ä½†æ˜¯è¿è¡Œä¸å¯è§ï¼‰ è¿è¡Œæ—¶ï¼ˆåœ¨.classä¸­è¿è¡Œå¯è§ï¼‰ æ³¨è§£çš„è§£æ æ‰€æœ‰å¯ä»¥è¢«æ³¨è§£ä¿®é¥°çš„å…ƒç´ éƒ½å®ç°äº†AnnotatedElementæ¥å£ï¼Œåº•å±‚ä¾èµ–æœ¬åœ°æ–¹æ³•ï¼ŒJVMåœ¨åŠ è½½ç±»çš„æ—¶å€™ä¼šè§£æ.classä¸­çš„æ³¨è§£ä¿¡æ¯å­˜å‚¨åœ¨å†…å­˜ä¸­ï¼Œå¹¶åˆ›å»ºæ³¨è§£ä»£ç†å¯¹è±¡è·å–æ³¨è§£å±æ€§å€¼ã€‚\nä½œç”¨åŸŸ ç±»ã€æ–¹æ³•ã€å±æ€§ã€æ„é€ å‡½æ•°ã€å±€éƒ¨å˜é‡ã€‚\nå¼‚å¸¸ Errorï¼šä¸¥é‡é—®é¢˜ï¼Œç¨‹åºæ— æ³•å¤„ç†ï¼Œæ— æ³•æ•æ‰ã€‚ RuntimeExceptionï¼šè¿è¡Œæ—¶çš„é—®é¢˜ï¼Œå¦‚éæ³•å†…å­˜è®¿é—®ã€‚ éè¿è¡Œæ—¶å¼‚å¸¸ï¼šç¼–è¯‘æ—¶å€™çš„é—®é¢˜ï¼Œå¦‚ç±»æ–‡ä»¶ä¸å­˜åœ¨ç­‰ã€‚ Try-Catch æ³¨æ„ï¼šfinallyä¸­çš„returnä¼šè¦†ç›–tryä¸­çš„ã€‚\nLambdaè¡¨è¾¾å¼å’ŒåŒ¿åå†…éƒ¨ç±» åŒ¿åå†…éƒ¨ç±»ï¼š\n1 2 3 4 new Runnable(){ @Override public void run(){} } lambdaè¡¨è¾¾å¼ï¼š\n1 () -\u0026gt; {} //ç­‰äºé‡å†™å‡½æ•°å¼æ¥å£å”¯ä¸€æ–¹æ³• å¼‚æ­¥ç¼–ç¨‹ Future è¡¨ç¤ºå¼‚æ­¥è®¡ç®—çš„ç»“æœï¼Œåªèƒ½é˜»å¡æˆ–è€…è½®è¯¢è·å–ï¼Œä¸æ”¯æŒå›è°ƒæ–¹æ³•ã€‚\nå›è°ƒåœ°ç‹±ï¼šæŒ‡çš„æ˜¯å½“å¼‚æ­¥æ“ä½œéœ€è¦é¡ºåºæ‰§è¡Œçš„æ—¶å€™ï¼Œéœ€è¦å°†æ¯ä¸ªæ“ä½œçš„å›è°ƒå‡½æ•°åµŒå¥—åœ¨ä¸Šä¸€ä¸ªå·¥ä½œçš„å›è°ƒä¸­ï¼Œå½¢æˆæ·±å±‚åµŒå¥—ã€‚\nCompletableFuture æ›´ä¸ºç®€æ´ï¼Œå¯è¯»æ€§æ›´å¥½ã€‚\nå¯ä»¥é€šè¿‡å‡½æ•°å¼ç¼–ç¨‹æ€æƒ³å¯¹å¼‚æ­¥è°ƒç”¨è¿›è¡Œç¼–æ’ã€‚\nï¼ˆä¾‹å­å¾…è¡¥å……ï¼‰\nå•ä¾‹æ¨¡å¼å®ç° åŒé‡æ£€æŸ¥é”å®šï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class SingleTon { // volatile å…³é”®å­—ä¿®é¥°å˜é‡ é˜²æ­¢æŒ‡ä»¤é‡æ’åº private static volatile SingleTon instance = null; private SingleTon(){} public static SingleTon getInstance(){ if(instance == null){ synchronized(SingleTon.class){ if(instance == null){ instance = new SingleTon(); } } } return instance; } } **ç¬¬ä¸€é‡æ£€æŸ¥ï¼š**ä¼˜åŒ–æ€§èƒ½ï¼Œå¦åˆ™æ¯æ¬¡éƒ½è¿›å…¥æ–¹æ³•çº§åŠ é”åŒæ­¥ã€‚\n**ç¬¬äºŒé‡æ£€æŸ¥ï¼š**è§£å†³ç«äº‰é—®é¢˜ã€‚\nä¸C++å¯¹æ¯”ï¼šä¸æ”¯æŒå±€éƒ¨é™æ€å˜é‡ã€‚\nä»£ç†æ¨¡å¼å’Œé€‚é…å™¨æ¨¡å¼ ä»£ç†æ¨¡å¼ ç•¥ã€‚\né€‚é…å™¨æ¨¡å¼ æŒ‡å°†æ—§ç±»é€‚é…æ–°æ¥å£çš„æ–°ç±»ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // ç›®æ ‡æ¥å£ï¼ˆæ–°æ¥å£ï¼‰ interface PaymentProcessor { void processPayment(double amount); } // é€‚é…è€…ï¼ˆæ—§ç±»ï¼‰ class OldPaymentSystem { void makePayment(double amount) { System.out.println(\u0026#34;æ—§æ”¯ä»˜ç³»ç»Ÿæ‰£æ¬¾\u0026#34;); } } // é€‚é…å™¨ class PaymentAdapter implements PaymentProcessor { private OldPaymentSystem oldSystem; @Override public void processPayment(double amount) { oldSystem.makePayment(amount); // è°ƒç”¨æ—§ç±»æ–¹æ³• } } å¯¹æ¯” ç»´åº¦ ä»£ç†æ¨¡å¼ é€‚é…å™¨æ¨¡å¼ æ ¸å¿ƒç›®æ ‡ æ§åˆ¶å¯¹å¯¹è±¡çš„è®¿é—®ï¼Œæ·»åŠ é¢å¤–åŠŸèƒ½ è§£å†³æ¥å£ä¸å…¼å®¹é—®é¢˜ï¼Œæ— åŠŸèƒ½å¢å¼ºã€‚ è§’è‰²å…³ç³» ä»£ç†ä¸ç›®æ ‡å¯¹è±¡å®ç°ç›¸åŒæ¥å£ é€‚é…å™¨å®ç°ç›®æ ‡æ¥å£ï¼Œä½†åŒ…è£…é€‚é…è€…ã€‚ åŠŸèƒ½å¢å¼º å¯æ·»åŠ é€»è¾‘ï¼ˆå¦‚æ—¥å¿—ã€æƒé™ï¼‰ ä»…è½¬æ¢æ¥å£ï¼Œä¸å¢å¼ºåŠŸèƒ½ã€‚ åº”ç”¨åœºæ™¯ æƒé™æ§åˆ¶ã€å»¶è¿ŸåŠ è½½ã€è¿œç¨‹è°ƒç”¨ æ—§ç³»ç»Ÿæ•´åˆã€ç¬¬ä¸‰æ–¹åº“å…¼å®¹ã€‚ å®ç°å…³é”® ä»£ç†æŒæœ‰ç›®æ ‡å¯¹è±¡å¼•ç”¨ é€‚é…å™¨æŒæœ‰é€‚é…è€…å¯¹è±¡å¼•ç”¨ã€‚ ä¸»è¦åŒºåˆ«ï¼šå°±æ˜¯ç›®çš„ä¸åŒï¼Œä¸€ä¸ªå¢å¼ºåŠŸèƒ½ï¼Œä¸€ä¸ªè½¬æ¢é€‚é…ã€‚\nI/O BIO/NIO/AIO BIO åŒæ­¥é˜»å¡IOï¼Œä¼ ç»Ÿjava.ioåŒ…ã€‚\nNIO Java1.4å¼•å…¥ï¼ŒåŒæ­¥éé˜»å¡IOï¼ŒåŒ…å«IOå¤šè·¯å¤ç”¨ï¼Œç»å…¸NIOæ¡†æ¶æ˜¯Nettyï¼Œå®ç°äº†Reactorå’ŒProactoræ¨¡å¼ã€‚\nAIO Java1.7å¼•å…¥ï¼Œå¼‚æ­¥IOï¼Œå¯¹å†…å­˜è®¿é—®ä¹Ÿæ˜¯å¼‚æ­¥çš„ã€‚\nNativeæ–¹æ³• ç±»ä¼¼äºC++åŠ¨æ€åº“åŠ è½½å‡½æ•° ï¼Œæ­¥éª¤æœ‰ä»¥ä¸‹å‡ æ­¥ï¼š\n**ç”ŸæˆJNIå¤´æ–‡ä»¶ï¼š**ä½¿ç”¨javahå·¥å…·ä»ä½ çš„Javaç±»ç”ŸæˆC/C++çš„å¤´æ–‡ä»¶ï¼Œè¿™ä¸ªå¤´æ–‡ä»¶åŒ…å«äº†æ‰€æœ‰nativeæ–¹æ³•çš„åŸå‹ã€‚\n**ç¼–å†™æœ¬åœ°ä»£ç ï¼š**ä½¿ç”¨C/C++ç¼–å†™æœ¬åœ°æ–¹æ³•çš„å®ç°ï¼Œå¹¶ç¡®ä¿æ–¹æ³•ç­¾åä¸ç”Ÿæˆçš„å¤´æ–‡ä»¶ä¸­çš„åŸå‹åŒ¹é…ã€‚\n**ç¼–è¯‘æœ¬åœ°ä»£ç ï¼š**å°†C/C++ä»£ç ç¼–è¯‘æˆåŠ¨æ€é“¾æ¥åº“ï¼ˆDLLï¼Œåœ¨Windowsä¸Šï¼‰ï¼Œå…±äº«åº“ï¼ˆSOï¼Œåœ¨Linuxä¸Šï¼‰ã€‚\n**åŠ è½½æœ¬åœ°åº“ï¼š**åœ¨Javaç¨‹åºä¸­ï¼Œä½¿ç”¨System.loadLibrary()æ–¹æ³•æ¥åŠ è½½ä½ ç¼–è¯‘å¥½çš„æœ¬åœ°åº“ï¼Œè¿™æ ·JVMå°±èƒ½æ‰¾åˆ°å¹¶è°ƒç”¨nativeæ–¹æ³•çš„å®ç°äº†ã€‚\n","date":"2025-06-20T00:00:00Z","permalink":"https://sixiyida.github.io/p/%E5%85%AB%E8%82%A1%E6%96%87%E4%B9%8Bjava%E5%9F%BA%E7%A1%80/","title":"å…«è‚¡æ–‡ä¹‹JavaåŸºç¡€"},{"content":"å¤šçº¿ç¨‹ç«äº‰ä¸‹çš„é—®é¢˜ **åŸå­æ€§ï¼š**äº’æ–¥è®¿é—®ï¼ŒåŸå­æ“ä½œatomic/ä¸²è¡Œè®¿é—®synchronizedé™åˆ¶ã€‚\n**å¯è§æ€§ï¼š**ç›´æ¥æ“ä½œä¸»å†…å­˜ï¼Œä½¿ç”¨synchronizedå’Œvolatileå®ç°ã€‚\nvolatile\nè¯»å†™ç›´è¾¾ä¸»å†…å­˜ï¼Œç»•è¿‡ç¼“å­˜ã€‚ å†™ä»¥åå…¶ä»–CPUå˜é‡çš„ç¼“å­˜è‡ªåŠ¨å¤±æ•ˆå¼ºåˆ¶é‡æ–°åŠ è½½ã€‚ æœ‰åºæ€§ï¼š æŒ‡ä»¤é‡æ’åºå¯¼è‡´çš„çº¿ç¨‹è§‚æµ‹å…¶ä»–çº¿ç¨‹æŒ‡ä»¤æ‰§è¡Œé¡ºåºä¸ä¸€è‡´ã€‚\nçº¿ç¨‹çš„åˆ›å»ºæ–¹å¼ ç»§æ‰¿Threadç±»ï¼Œé‡å†™run()æ–¹æ³•ï¼Œç”¨start()æ–¹æ³•å¯åŠ¨çº¿ç¨‹ã€‚ å®ç°Runnableæ¥å£ï¼Œå‡½æ•°å¼ä¼ ç»™Threadæ„é€ å‡½æ•°ã€‚ å®ç°Callableæ¥å£ï¼Œå¹¶å°†å…¶å°è£…å…¥FutureTaskï¼Œæœ€åå‡½æ•°å¼ä¼ ç»™Threadæ„é€ å‡½æ•°ã€‚ Executoræ¡†æ¶ï¼Œexecutor.submitå³å¯ã€‚ å¦‚ä½•åœæ­¢çº¿ç¨‹è¿è¡Œ åœ¨runæ–¹æ³•ä¸­åˆ¤æ–­interruptedçŠ¶æ€ï¼Œå¦‚æœæ˜¯çš„è¯æŠ›å‡ºå¼‚å¸¸/returnã€‚ç„¶åç›´æ¥è°ƒç”¨interruptæ–¹æ³•å³å¯ã€‚å¦‚æœçº¿ç¨‹æ­£åœ¨æ‰§è¡ŒThread.sleep() / Thread.join() / Object.wait()ç­‰å¯ä¸­æ–­æ–¹æ³•ï¼Œåˆ™è§£é™¤é˜»å¡å¹¶æŠ›å‡ºå¼‚å¸¸ã€‚ æ ¹æ®çº¦å®šå˜é‡æ˜¾å¼åˆ¤æ–­ é€šè¿‡executor + futureå–æ¶ˆä»»åŠ¡ æœ‰èµ„æºçš„æƒ…å†µä¸‹ç›´æ¥é”€æ¯èµ„æºï¼Œä¼šå¼¹å‡ºå¼‚å¸¸ä»¥é€€å‡º Javaçº¿ç¨‹çš„çŠ¶æ€ NEWï¼šå°šæœªstart\nRUNNABLEï¼šå·²ç»startç­‰å¾…è°ƒåº¦/æ­£åœ¨è¿è¡Œ\nBLOCKEDï¼šç­‰å¾…é”\nWAITINGï¼šç­‰å¾…é›¶ä¸€çº¿ç¨‹æ“ä½œ\nTIMED_WAITINGï¼šå…·æœ‰ç­‰å¾…æ—¶é—´çš„ç­‰å¾…\nTERMINATEDï¼šç»ˆæ­¢\nsleep vs wait sleepï¼šä»»æ„ä½ç½®è°ƒç”¨ï¼Œå’Œé”æ— å…³ï¼Œè¶…æ—¶é‡Šæ”¾ï¼Œé‡Šæ”¾cpuä¸æ˜¯æ”¾é”\nwaitï¼šæœ‰é”ä¸‹è°ƒç”¨ï¼Œnotify/è¶…æ—¶å”¤é†’ï¼Œä½œç”¨ä¸»è¦æ˜¯é‡Šæ”¾é”\nblocked vs waiting blockedï¼šé”ç«äº‰å¤±è´¥è¿›å…¥ï¼Œåˆ°é”å¯ç”¨è§£å¼€é˜»å¡ï¼Œè‡ªåŠ¨è§¦å‘\nwaitingï¼šç‰¹å®šæ–¹æ³•ä¸»åŠ¨å”¤é†’\nçº¿ç¨‹çš„é€šä¿¡æ–¹å¼ Objectç±»ä¸‹wait/notify/notifyAllæ–¹æ³•ã€‚\nLockå’ŒConditionæ¥å£ï¼š\n1 2 3 Condition condition = lock.newCondition(); condition.await(); condition.signal(); åŸºäºvolatileçš„å…±äº«å˜é‡\nCountDownLatchï¼šè®¡æ•°åŒæ­¥è¾…åŠ©ç±»\n1 2 3 4 5 6 CountDownLatch latch = new CountDownLatch(threadCount); new Thread(() -\u0026gt; { latch.countDown(); }).start(); latch.await(); CyclicBarrierï¼šçº¿ç¨‹å†…éƒ¨å±éšœç‚¹ï¼Œç­‰å¾…æ‰€æœ‰/ä¸€å®šçº¿ç¨‹åˆ°è¾¾å±éšœç‚¹åç»§ç»­è¿è¡Œã€‚\n1 2 3 4 5 var barrier = new CyclicBarrier(threadCount, () -\u0026gt; {}); new Thread(() -\u0026gt; { barrier.await(;) }).start(); Semaphoreï¼šè®¡æ•°ä¿¡å·é‡ï¼Œå…è®¸æ§åˆ¶è®¿é—®èµ„æºçš„çº¿ç¨‹æ•°é‡\n1 2 3 Semaphore(int permits); // æ„é€ å‡½æ•° acquire(); // çº¿ç¨‹å†…éƒ¨aquire release(); // çº¿ç¨‹å†…éƒ¨é‡Šæ”¾ Javaçº¿ç¨‹å®‰å…¨çš„ä¿è¯ synchronizedï¼šé€šè¿‡ç›‘è§†å™¨é”å®ç°çš„åŒæ­¥ä»£ç å—\nvolatileï¼šé€šè¿‡ç›´å†™å†…å­˜/å¤±æ•ˆé€šçŸ¥æœºåˆ¶å®ç°çš„ç¡®ä¿å˜é‡åœ¨ä¸åŒçº¿ç¨‹ä¸­çš„è§‚æµ‹ä¸€è‡´æ€§\nlock/ReentrantLockï¼šæ›´å¤šé”\nAtomicï¼šåŸå­æ“ä½œ\nThreadLocalï¼šå½“å‰çº¿ç¨‹ä¸­çš„å­˜å‚¨ç©ºé—´\nå¹¶å‘å®‰å…¨é›†åˆ\nJUCå·¥å…·ç±»ï¼šå¦‚ä¿¡å·é‡/å±éšœç­‰\nå¸¸è§é” ç›‘è§†å™¨é”ï¼ˆsychronizedï¼‰ï¼š Javaæä¾›çš„åŸå­æ€§å†…ç½®é”ï¼Œåœ¨åŒæ­¥çš„ä»£ç å—å‰ååŠ ä¸Šmonitorrenterå’Œmonitorexitå­—èŠ‚ç æŒ‡ä»¤ï¼Œåº•å±‚ä¾èµ–æ“ä½œç³»ç»Ÿäº’æ–¥é”ã€‚\næ¥ç€å°±æ˜¯å¯é‡å…¥é”çš„é€»è¾‘ã€‚\n1.6åçš„é”å‡çº§æœºåˆ¶ï¼š\nNo Lock -\u0026gt; ï¼ˆé¦–æ¬¡è®¿é—®åŒæ­¥å—ï¼‰-\u0026gt; Biased Lock(æ¯”å¯¹çº¿ç¨‹ID) -\u0026gt; (äºŒçº¿ç¨‹é”ç«äº‰)\n-\u0026gt; è½»é‡çº§é” (CAS) -\u0026gt; (CASå¤±è´¥ )-\u0026gt; å¤§é”\n**è½»é‡çº§é”ï¼š**çº¿ç¨‹å¤‡ä»½é”å¯¹è±¡Mark Wordï¼ŒCAS Mark WordæŒ‡å‘å¤‡ä»½çš„æŒ‡é’ˆ\nCASæˆåŠŸï¼šçº¿ç¨‹è·å¾—é”\nCASå¤±è´¥ï¼šæ£€æŸ¥æ˜¯å¦é‡å…¥ï¼Œå¦‚æœé‡å…¥åˆ™è¿›å…¥ï¼Œå¦‚æœä¸æ˜¯åˆ™é”å‡çº§\nè§£é”ï¼šç”¨CASè¿˜åŸMark Word\nè¿˜åŸæˆåŠŸï¼šé”é‡Šæ”¾\nè¿˜åŸå¤±è´¥ï¼šå·²ç»æ˜¯å¤§é”ï¼Œå”¤é†’é˜»å¡çº¿ç¨‹\nä¼˜åŒ–ï¼šé”æ¶ˆé™¤ï¼ˆæ— ç«äº‰å¯èƒ½æ€§æ¶ˆé™¤é”ï¼‰ã€é”ç²—åŒ–ï¼ˆå¤šé”åˆä¸€ï¼‰ã€è‡ªæ—‹é”ï¼ˆå‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€ï¼‰\nReentrantLock å¼•ç”¨è®¡æ•°ï¼Œè¿›å…¥+1ï¼Œå‡ºå»-1ï¼Œæ˜¯0åˆ™é‡Šæ”¾é”ã€‚\nå…¶ä»–é” è¯»å†™é”ï¼šè¯»å†™åˆ†ç¦»çš„é”ï¼Œè¯»å’Œå†™çº¿ç¨‹åˆ†å¼€è·å–é”\nä¹è§‚é”ï¼šç‰ˆæœ¬å·æ¯”è¾ƒ\nè‡ªæ—‹é”/äº’æ–¥é”ï¼šè§OS\nAQS (AbstractQueuedSynchronizer) 1. åŒæ­¥çŠ¶æ€ï¼ˆint stateï¼‰ æ ¸å¿ƒå…±äº«å˜é‡ï¼ˆvolatile int stateï¼‰ ç”±å­ç±»å®šä¹‰è¯­ä¹‰ï¼ˆä¾‹å¦‚ï¼‰ï¼š ReentrantLockï¼šé‡å…¥æ¬¡æ•° Semaphoreï¼šå‰©ä½™è®¸å¯æ•° CountDownLatchï¼šæœªå®Œæˆè®¡æ•° 2. FIFO ç­‰å¾…é˜Ÿåˆ—ï¼ˆCLH å˜ä½“ï¼‰ åŒå‘é“¾è¡¨ç»“æ„ï¼ˆéä¸¥æ ¼çš„ CLH é˜Ÿåˆ—ï¼‰\nèŠ‚ç‚¹ Nodeå­˜å‚¨çº¿ç¨‹ + ç­‰å¾…çŠ¶æ€ï¼š\n1 2 3 4 5 6 static final class Node { volatile int waitStatus; // çŠ¶æ€ï¼šCANCELLEDã€SIGNALã€CONDITIONç­‰ volatile Node prev; // å‰é©±èŠ‚ç‚¹ volatile Node next; // åç»§èŠ‚ç‚¹ volatile Thread thread; // ç­‰å¾…çº¿ç¨‹ } 3. æ¨¡æ¿æ–¹æ³•æ¨¡å¼ å­ç±»ä»…éœ€å®ç°å…³é”®é’©å­æ–¹æ³•ï¼š\næ¨¡ç‰ˆæ–¹æ³• éœ€å®ç°çš„æ–¹æ³• èŒè´£ acquire() tryAcquire() å°è¯•ç‹¬å è·å–é”ï¼ˆéœ€æ“ä½œ stateï¼‰ release() tryRelease() å°è¯•ç‹¬å é‡Šæ”¾é” acquireShared() tryAcquireShared() å°è¯•å…±äº«è·å–ï¼ˆå¦‚ Semaphore è®¸å¯ï¼‰ releaseShared() tryReleaseShared() å°è¯•å…±äº«é‡Šæ”¾ 4. çº¿ç¨‹é˜»å¡ä¸å”¤é†’æœºåˆ¶ LockSupport.park()ï¼šé˜»å¡å½“å‰çº¿ç¨‹ LockSupport.unpark(thread)ï¼šå”¤é†’æŒ‡å®šçº¿ç¨‹ ThreadLocalçš„åŸç† æ¯ä¸ªçº¿ç¨‹ä¸­éƒ½æœ‰ä¸€ä¸ªç‹¬ç«‹çš„ThreadLocalMapï¼Œè¿™ä¸ªä¸œè¥¿æ˜¯å“ˆå¸Œè¡¨ï¼Œä»–çš„keyæ˜¯ThreadLocalï¼Œvalueæ˜¯å€¼ã€‚\nçº¿ç¨‹æ± çš„ThreadLocalæ³„éœ²é—®é¢˜\nç”±äºThreadLocalMapä¸­çš„valueæ˜¯å¼ºå¼•ç”¨ï¼Œçº¿ç¨‹ä¸ç»“æŸGCä¸èƒ½å›æ”¶ï¼Œæ‰€ä»¥ç”±äºçº¿ç¨‹æ± çº¿ç¨‹é•¿ä¹…è¿è¡Œï¼Œå¯¼è‡´èµ„æºæ— æ³•è‡ªåŠ¨é‡Šæ”¾ã€‚\nCASçš„ABAé—®é¢˜ å³CSä¹‹é—´å­˜åœ¨A-\u0026gt;B-\u0026gt;Açš„å˜åŒ–ï¼Œä½†æ˜¯CASä¼šæˆåŠŸã€‚\nè§£å†³æ–¹æ³•ï¼šç»´æŠ¤ä¸€ä¸ªç‰ˆæœ¬å·ï¼ˆJavaçš„åŠæ³•ï¼‰\nvolatileçš„ä½œç”¨ ä¿è¯å˜é‡å¯¹æ‰€æœ‰çº¿ç¨‹çš„å¯è§æ€§ ç¦æ­¢é‡æ’åºä¼˜åŒ–ï¼šä¿è¯å†™åœ¨æ‰€æœ‰è¯»å†™å®Œæˆä¹‹åï¼Œä¿è¯è¯»åœ¨æ‰€æœ‰è¯»å†™ä¹‹å‰è¿›è¡Œã€‚ å…¬å¹³é”å’Œéå…¬å¹³é” **å…¬å¹³é”ï¼š**å…ˆè¿›ç­‰å¾…é˜Ÿåˆ—ï¼Œéœ€è¦åˆ‡æ¢ä¸¤æ¬¡ä¸Šä¸‹æ–‡ï¼Œæ…¢\néå…¬å¹³é”ï¼šå…ˆæŠ¢é”ï¼Œå¤±è´¥è¿›ç­‰å¾…é˜Ÿåˆ—ï¼ŒæˆåŠŸåˆ™ä¸éœ€è¦åˆ‡æ¢ä¸Šä¸‹æ–‡ï¼Œå¿«\nsynchronizedæ˜¯éå…¬å¹³é”ï¼Œå¯é‡å…¥é”æ˜¯å…¬å¹³é”ã€‚\nçº¿ç¨‹æ±  çº¿ç¨‹æ± 7ä¸ªå‚æ•° æ ¸å¿ƒçº¿ç¨‹æ•°ã€æœ€å¤§çº¿ç¨‹æ•°ã€é˜»å¡é˜Ÿåˆ—ã€æœ€å¤§æ·˜æ±°æ—¶é—´ã€å·¥å‚ç±»ã€æ·˜æ±°ç­–ç•¥ã€æ—¶é—´å•ä½\næ‹’ç»ç­–ç•¥ å¼‚å¸¸æ‹’ç»ã€é»˜æ‹’ç»ã€ä¸»çº¿ç¨‹æ‰§è¡Œã€æŠ›å¼ƒæœ€è€ä»»åŠ¡\nçº¿ç¨‹æ± å‚æ•°è®¾ç½® CPUå¯†é›†å‹ï¼šCPUæ ¸+1\nIOå¯†é›†å‹ï¼šCPUæ ¸*2\nä¸ºä»€ä¹ˆä¸èƒ½ç”¨é»˜è®¤executor FixedThreadPoolå†…éƒ¨ä½¿ç”¨æ— ç•Œä»»åŠ¡é˜Ÿåˆ—ï¼Œå¯¼è‡´å¦‚æœæ¶ˆè´¹é€Ÿåº¦å°äºç”Ÿäº§é€Ÿåº¦ï¼Œä¼šæ— é™å †ç§¯ï¼Œå¯¼è‡´å†…å­˜å ç”¨è¿‡å¤šOOMã€‚\nCachedThreadPoolå†…éƒ¨ä½¿ç”¨æ— ç•Œä»»åŠ¡é˜Ÿåˆ—ï¼Œä¸”æ ¸å¿ƒçº¿ç¨‹æ•°ä¸º0ï¼Œå¦‚æœç”Ÿäº§é€Ÿåº¦å¤§äºæ¶ˆè´¹é€Ÿåº¦ï¼Œä¼šå¯¼è‡´çº¿ç¨‹æ— é™åˆ›å»ºï¼Œå¯¼è‡´CPUè¿‡è½½ç­‰é—®é¢˜ã€‚\n","date":"2025-06-20T00:00:00Z","permalink":"https://sixiyida.github.io/p/%E5%85%AB%E8%82%A1%E6%96%87%E4%B9%8Bjava%E5%B9%B6%E5%8F%91/","title":"å…«è‚¡æ–‡ä¹‹Javaå¹¶å‘"},{"content":"spring-ai-alibaba-graph-core æºç é˜…è¯» â€‹\tSpring AI Alibaba Graph æ˜¯ç¤¾åŒºæ ¸å¿ƒå®ç°ä¹‹ä¸€ï¼Œä¹Ÿæ˜¯æ•´ä¸ªæ¡†æ¶åœ¨è®¾è®¡ç†å¿µä¸ŠåŒºåˆ«äº Spring AI åªåšåº•å±‚åŸå­æŠ½è±¡çš„åœ°æ–¹ï¼ŒSpring AI Alibaba æœŸæœ›å¸®åŠ©å¼€å‘è€…æ›´å®¹æ˜“çš„æ„å»ºæ™ºèƒ½ä½“åº”ç”¨ã€‚åŸºäº Graph å¼€å‘è€…å¯ä»¥æ„å»ºå·¥ä½œæµã€å¤šæ™ºèƒ½ä½“åº”ç”¨ã€‚Spring AI Alibaba Graph åœ¨è®¾è®¡ç†å¿µä¸Šå€Ÿé‰´ Langgraphï¼Œå› æ­¤åœ¨ä¸€å®šç¨‹åº¦ä¸Šå¯ä»¥ç†è§£ä¸ºæ˜¯ Java ç‰ˆçš„ Langgraph å®ç°ï¼Œç¤¾åŒºåœ¨æ­¤åŸºç¡€ä¸Šå¢åŠ äº†å¤§é‡é¢„ç½® Nodeã€ç®€åŒ–äº† State å®šä¹‰è¿‡ç¨‹ç­‰ï¼Œè®©å¼€å‘è€…æ›´å®¹æ˜“ç¼–å†™å¯¹ç­‰ä½ä»£ç å¹³å°çš„å·¥ä½œæµã€å¤šæ™ºèƒ½ä½“ç­‰ã€‚\næ ¸å¿ƒåŠŸèƒ½\næ”¯æŒ Multi-agentï¼Œå†…ç½® ReAct Agentã€Supervisor ç­‰å¸¸è§„æ™ºèƒ½ä½“æ¨¡å¼ æ”¯æŒå·¥ä½œæµï¼Œå†…ç½®å·¥ä½œæµèŠ‚ç‚¹ï¼Œä¸ä¸»æµä½ä»£ç å¹³å°å¯¹é½ åŸç”Ÿæ”¯æŒ Streaming Human-in-the-loopï¼Œé€šè¿‡äººç±»ç¡®è®¤èŠ‚ç‚¹ï¼Œæ”¯æŒä¿®æ”¹çŠ¶æ€ã€æ¢å¤æ‰§è¡Œ æ”¯æŒè®°å¿†ä¸æŒä¹…å­˜å‚¨ æ”¯æŒæµç¨‹å¿«ç…§ æ”¯æŒåµŒå¥—åˆ†æ”¯ã€å¹¶è¡Œåˆ†æ”¯ PlantUMLã€Mermaid å¯è§†åŒ–å¯¼å‡º 1 StateGraph 1.1 åŸºç¡€ç»“æ„ 1 2 3 4 5 6 7 8 9 10 public class StateGraph { // æ ¸å¿ƒæ•°æ®ç»“æ„ final Nodes nodes = new Nodes(); // å­˜å‚¨æ‰€æœ‰èŠ‚ç‚¹ final Edges edges = new Edges(); // å­˜å‚¨æ‰€æœ‰è¾¹ // ç‰¹æ®ŠèŠ‚ç‚¹å¸¸é‡ public static final String END = \u0026#34;__END__\u0026#34;; // ç»“æŸèŠ‚ç‚¹ public static final String START = \u0026#34;__START__\u0026#34;; // èµ·å§‹èŠ‚ç‚¹ public static final String ERROR = \u0026#34;__ERROR__\u0026#34;; // é”™è¯¯èŠ‚ç‚¹ } 1.2 æ„é€ æ–¹æ³• 1 public StateGraph(String name, KeyStrategyFactory keyStrategyFactory, PlainTextStateSerializer stateSerializer) å‚æ•°å¿…é€‰KeyStrategyFactoryï¼Œå…¶ä»–å¯é€‰ï¼Œåºåˆ—åŒ–é»˜è®¤JacksonSerializer()ã€‚\n1.3 èŠ‚ç‚¹ç®¡ç† èŠ‚ç‚¹å…·ä½“å®ç°è¯·è§2\n1 2 3 4 5 6 7 8 public static class Nodes { public final Set\u0026lt;Node\u0026gt; elements; // èŠ‚ç‚¹é›†åˆ // èŠ‚ç‚¹æ“ä½œæ–¹æ³• public boolean anyMatchById(String id) // æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨ public List\u0026lt;SubStateGraphNode\u0026gt; onlySubStateGraphNodes() // è·å–å­å›¾èŠ‚ç‚¹ public List\u0026lt;Node\u0026gt; exceptSubStateGraphNodes() // è·å–éå­å›¾èŠ‚ç‚¹ } 1.4 è¾¹ç®¡ç† 1 2 3 4 5 6 7 public static class Edges { public final List\u0026lt;Edge\u0026gt; elements; // è¾¹é›†åˆ // è¾¹æ“ä½œæ–¹æ³• public Optional\u0026lt;Edge\u0026gt; edgeBySourceId(String sourceId) // æ ¹æ®æºèŠ‚ç‚¹æŸ¥æ‰¾è¾¹ public List\u0026lt;Edge\u0026gt; edgesByTargetId(String targetId) // æ ¹æ®ç›®æ ‡èŠ‚ç‚¹æŸ¥æ‰¾è¾¹ } 1.5 æ·»åŠ èŠ‚ç‚¹ 1 2 3 4 5 6 7 8 // æ·»åŠ æ™®é€šèŠ‚ç‚¹ public StateGraph addNode(String id, AsyncNodeAction action) // æ·»åŠ å¸¦é…ç½®çš„èŠ‚ç‚¹ public StateGraph addNode(String id, AsyncNodeActionWithConfig actionWithConfig) // æ·»åŠ å­å›¾èŠ‚ç‚¹ public StateGraph addNode(String id, StateGraph subGraph) // æ·»åŠ CommandèŠ‚ç‚¹ public StateGraph addNode(String id, AsyncCommandAction action, Map\u0026lt;String, String\u0026gt; mappings) 1.6 æ·»åŠ è¾¹ 1 2 3 4 // æ·»åŠ æ™®é€šè¾¹ public StateGraph addEdge(String sourceId, String targetId) // æ·»åŠ æ¡ä»¶è¾¹ public StateGraph addConditionalEdges(String sourceId, AsyncCommandAction condition, Map\u0026lt;String, String\u0026gt; mappings) 1.7 å›¾éªŒè¯ã€ç¼–è¯‘å’Œå¯è§†åŒ– 1 2 3 4 5 6 // éªŒè¯å›¾çš„æ­£ç¡®æ€§ void validateGraph() throws GraphStateException // ç¼–è¯‘å›¾ public CompiledGraph compile(CompileConfig config) throws GraphStateException // å¯è§†åŒ– public GraphRepresentation getGraph(GraphRepresentation.Type type, String title) 1.8 åºåˆ—åŒ–å™¨ 1 2 3 static class JacksonSerializer extends JacksonStateSerializer static class GsonSerializer extends GsonStateSerializer 1.9 çŠ¶æ€ç®¡ç† 1 2 3 4 // çŠ¶æ€å·¥å‚ private OverAllStateFactory overAllStateFactory; // é”®ç­–ç•¥å·¥å‚ private KeyStrategyFactory keyStrategyFactory; 2 Node 2.1 NodeåŸºç¡€èŠ‚ç‚¹ 1 2 3 4 5 6 7 8 9 public class Node { private final String id; // èŠ‚ç‚¹å”¯ä¸€æ ‡è¯† private final ActionFactory actionFactory; // åŠ¨ä½œå·¥å‚ // åŠ¨ä½œå·¥å‚æ¥å£ public interface ActionFactory { AsyncNodeActionWithConfig apply(CompileConfig config) throws GraphStateException; } } 2.2 ParalellNode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class ParallelNode extends Node { public static final String PARALLEL_PREFIX = \u0026#34;__PARALLEL__\u0026#34;; // å¹¶è¡ŒåŠ¨ä½œå®ç° record AsyncParallelNodeAction( List\u0026lt;AsyncNodeActionWithConfig\u0026gt; actions, // å¹¶è¡Œæ‰§è¡Œçš„åŠ¨ä½œåˆ—è¡¨ Map\u0026lt;String, KeyStrategy\u0026gt; channels // é€šé“ç­–ç•¥ ) implements AsyncNodeActionWithConfig { // å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰åŠ¨ä½œ public CompletableFuture\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; apply(OverAllState state, RunnableConfig config) { // ä½¿ç”¨ CompletableFuture å®ç°å¹¶è¡Œæ‰§è¡Œ } } } å…·ä½“æµè½¬é€»è¾‘å‚è§8.2.1.3 å¹¶è¡ŒèŠ‚ç‚¹ã€‚\n2.3 å­å›¾èŠ‚ç‚¹ 2.3.1 å­å›¾èŠ‚ç‚¹æ¥å£ 1 2 3 4 5 6 7 public interface SubGraphNode { String PREFIX_FORMAT = \u0026#34;%s-%s\u0026#34;; // èŠ‚ç‚¹IDæ ¼å¼åŒ–æ¨¡æ¿ String id(); // è·å–èŠ‚ç‚¹ID StateGraph subGraph(); // è·å–å­å›¾ String formatId(String nodeId); // æ ¼å¼åŒ–èŠ‚ç‚¹ID } 2.3.2 çŠ¶æ€å›¾å­å›¾èŠ‚ç‚¹ 1 2 3 4 5 6 7 8 public class SubStateGraphNode extends Node implements SubGraphNode { private final StateGraph subGraph; // å­å›¾ // æ ¼å¼åŒ–èŠ‚ç‚¹ID public String formatId(String nodeId) { return SubGraphNode.formatId(id(), nodeId); } } 2.3.3 ç¼–è¯‘åçš„å­å›¾èŠ‚ç‚¹ 1 2 3 4 5 6 7 8 public class SubCompiledGraphNode extends Node implements SubGraphNode { private final CompiledGraph subGraph; // ç¼–è¯‘åçš„å­å›¾ public SubCompiledGraphNode(String id, CompiledGraph subGraph) { super(id, (config) -\u0026gt; new SubCompiledGraphNodeAction(subGraph)); this.subGraph = subGraph; } } 3 Edge 3.1 åŸºç¡€è¾¹Edge 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public record Edge(String sourceId, List\u0026lt;EdgeValue\u0026gt; targets) { // æ„é€ å‡½æ•° public Edge(String sourceId, EdgeValue target) { this(sourceId, List.of(target)); } // åˆ¤æ–­æ˜¯å¦ä¸ºå¹¶è¡Œè¾¹ public boolean isParallel() { return targets.size() \u0026gt; 1; } // éªŒè¯è¾¹çš„æœ‰æ•ˆæ€§ public void validate(StateGraph.Nodes nodes) throws GraphStateException { // éªŒè¯æºèŠ‚ç‚¹å­˜åœ¨ // éªŒè¯ç›®æ ‡èŠ‚ç‚¹å­˜åœ¨ // éªŒè¯å¹¶è¡Œè¾¹çš„ç›®æ ‡ä¸é‡å¤ } } 3.2 EdgeCondition 1 2 3 4 5 6 public record EdgeCondition( AsyncCommandAction action, // å¼‚æ­¥å‘½ä»¤åŠ¨ä½œ Map\u0026lt;String, String\u0026gt; mappings // æ¡ä»¶æ˜ å°„ ) { // æ¡ä»¶æ‰§è¡Œé€»è¾‘ } 3.3 EdgeValue 1 2 3 4 5 6 7 8 9 10 11 public record EdgeValue(String id, EdgeCondition value) { // ç®€å•è¾¹å€¼ï¼ˆåªæœ‰IDï¼‰ public EdgeValue(String id) { this(id, null); } // æ¡ä»¶è¾¹å€¼ï¼ˆåªæœ‰æ¡ä»¶ï¼‰ public EdgeValue(EdgeCondition value) { this(null, value); } } 4 Command Commandæ˜¯ä¸€ä¸ªrecordç±»ï¼ŒåŒ…å«ä¸¤ä¸ªæ ¸å¿ƒå±æ€§ï¼š\n1 public record Command(String gotoNode, Map\u0026lt;String, Object\u0026gt; update) Commandç”¨äºç”¨äºåœ¨å›¾çš„æ‰§è¡Œè¿‡ç¨‹ä¸­åŠ¨æ€åœ°å†³å®šä¸‹ä¸€ä¸ªè¦æ‰§è¡Œçš„èŠ‚ç‚¹å¹¶æ›´æ–°çŠ¶æ€ã€‚\n4.1 CommandAction 1 2 3 4 5 6 @FunctionalInterface public interface CommandAction { Command apply(OverAllState state, RunnableConfig config) throws Exception; } å®šä¹‰äº†è¿”å›Commandçš„é€»è¾‘ï¼ŒåŒæ—¶ï¼Œå®ƒå¯ä»¥æ˜¯å¼‚æ­¥çš„ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public interface AsyncCommandAction extends BiFunction\u0026lt;OverAllState, RunnableConfig, CompletableFuture\u0026lt;Command\u0026gt;\u0026gt; { static AsyncCommandAction node_async(CommandAction syncAction) { return (state, config) -\u0026gt; { var result = new CompletableFuture\u0026lt;Command\u0026gt;(); try { result.complete(syncAction.apply(state, config)); } catch (Exception e) { result.completeExceptionally(e); } return result; }; } static AsyncCommandAction of(AsyncEdgeAction action) { return (state, config) -\u0026gt; action.apply(state).thenApply(Command::new); } } 4.2 Commandçš„ä½¿ç”¨ 4.2.1 ä½œä¸ºèŠ‚ç‚¹ä½¿ç”¨ 1 2 3 public StateGraph addNode(String id, AsyncCommandAction action, Map\u0026lt;String, String\u0026gt; mappings) throws GraphStateException { return addNode(id, new CommandNode(id, action, mappings)); } 4.2.1.1 CommandNode applyæ–¹æ³•ç›´æ¥è¿”å›ä¸€ä¸ªåŒ…å«æœ‰CommandActionå’Œmappingsçš„completeFutureã€‚\nè¿™å—çš„mappingsæ˜¯æŒ‡ï¼šå½“Commandè¿”å›keyæ—¶ï¼Œè·³è½¬åˆ°valueçš„èŠ‚ç‚¹ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class CommandNode extends Node { private final Map\u0026lt;String, String\u0026gt; mappings; private final AsyncCommandAction action; public CommandNode(String id, AsyncCommandAction action, Map\u0026lt;String, String\u0026gt; mappings) { super(id, (config) -\u0026gt; new AsyncCommandNodeActionWithConfig(action, mappings)); this.mappings = mappings; this.action = action; } public Map\u0026lt;String, String\u0026gt; getMappings() { return mappings; } public AsyncCommandAction getAction() { return action; } public record AsyncCommandNodeActionWithConfig(AsyncCommandAction action, Map\u0026lt;String, String\u0026gt; mappings) implements AsyncNodeActionWithConfig { @Override public CompletableFuture\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; apply(OverAllState state, RunnableConfig config) { return CompletableFuture.completedFuture(Map.of(\u0026#34;command\u0026#34;, action, \u0026#34;mappings\u0026#34;, mappings)); } } } 4.2.2 ä½œä¸ºæ¡ä»¶è¾¹çš„æ¡ä»¶ä½¿ç”¨ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public StateGraph addConditionalEdges(String sourceId, AsyncCommandAction condition, Map\u0026lt;String, String\u0026gt; mappings) throws GraphStateException { if (Objects.equals(sourceId, END)) { throw Errors.invalidEdgeIdentifier.exception(END); } if (mappings == null || mappings.isEmpty()) { throw Errors.edgeMappingIsEmpty.exception(sourceId); } var newEdge = new Edge(sourceId, new EdgeValue(new EdgeCondition(condition, mappings))); if (edges.elements.contains(newEdge)) { throw Errors.duplicateConditionalEdgeError.exception(sourceId); } else { edges.elements.add(newEdge); } return this; } 5 OverAllState OverAllState æ˜¯çŠ¶æ€ç®¡ç†çš„æ ¸å¿ƒï¼Œå®ƒè´¯ç©¿æ•´ä¸ªå›¾çš„æ‰§è¡Œè¿‡ç¨‹ã€‚\næ‰€æœ‰çš„ Action éƒ½éœ€è¦ä¾èµ–çŠ¶æ€æ¥æ‰§è¡Œå’Œä¼ é€’æ•°æ®ã€‚\n5.1 æ ¸å¿ƒæ•°æ®ç»“æ„ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public final class OverAllState implements Serializable { // çŠ¶æ€æ•°æ®å­˜å‚¨ private final Map\u0026lt;String, Object\u0026gt; data; // é”®ç­–ç•¥æ˜ å°„ private final Map\u0026lt;String, KeyStrategy\u0026gt; keyStrategies; // æ¢å¤æ ‡å¿— private Boolean resume; // äººå·¥åé¦ˆ private HumanFeedback humanFeedback; // ä¸­æ–­æ¶ˆæ¯ private String interruptMessage; } 5.2 çŠ¶æ€æ§åˆ¶ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public void cover(OverAllState overAllState){ // æ›¿æ¢æ‰€æœ‰æ•°æ® } public OverAllState input(Map\u0026lt;String, Object\u0026gt; input) { // inputæ˜¯nullæˆ–ç©ºç›´æ¥è¿”å› // ä½¿ç”¨keyStrategiesæ“ä½œkeyå¯¹åº”value Map\u0026lt;String, KeyStrategy\u0026gt; keyStrategies = keyStrategies(); input.keySet().stream().filter(key -\u0026gt; keyStrategies.containsKey(key)).forEach(key -\u0026gt; { this.data.put(key, keyStrategies.get(key).apply(value(key, null), input.get(key))); }); return this; } public Map\u0026lt;String, Object\u0026gt; updateState(Map\u0026lt;String, Object\u0026gt; partialState) { // ç”¨partialStateæ›´æ–°çŠ¶æ€ï¼Œå’Œinputä¸€æ · } public static Map\u0026lt;String, Object\u0026gt; updateState(Map\u0026lt;String, Object\u0026gt; state, Map\u0026lt;String, Object\u0026gt; partialState, Map\u0026lt;String, KeyStrategy\u0026gt; keyStrategies){ // åŒä¸Š } private static Map\u0026lt;String, Object\u0026gt; updatePartialStateFromSchema(Map\u0026lt;String, Object\u0026gt; state, Map\u0026lt;String, Object\u0026gt; partialState, Map\u0026lt;String, KeyStrategy\u0026gt; keyStrategies){ // è¿”å›æ›´æ–°åçš„partialStateä½†ä¸æ›´æ–°çŠ¶æ€ } 5.3 ç­–ç•¥æ§åˆ¶ 1 2 3 4 5 6 // æ³¨å†Œé”®ç­–ç•¥ public OverAllState registerKeyAndStrategy(String key, KeyStrategy strategy) public OverAllState registerKeyAndStrategy(Map\u0026lt;String, KeyStrategy\u0026gt; keyStrategies) // æ£€æŸ¥ç­–ç•¥ public boolean containStrategy(String key) 6 Action æä¾›äº†Nodeã€Edgeã€Commandçš„åŒå¼‚æ­¥actionæ¥å£ï¼Œå…¶ä¸­åŒæ­¥actionå¯ä»¥è½¬æ¢ä¸ºå¼‚æ­¥ã€‚\n1 2 3 4 5 6 7 8 9 10 // DeepResearchä¸­çš„èŠ‚ç‚¹ public class BackgroundInvestigationNode implements NodeAction { @Override public Map\u0026lt;String, Object\u0026gt; apply(OverAllState state) throws Exception { //... return resultMap; } } 7 Config 7.1 CompileConfig CompileConfigä¸»è¦ç”¨äºåœ¨å›¾ç¼–è¯‘é˜¶æ®µè®¾ç½®å„ç§é…ç½®é€‰é¡¹ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class CompileConfig { // æ£€æŸ¥ç‚¹ä¿å­˜å™¨é…ç½® private SaverConfig saverConfig = new SaverConfig().register(MEMORY, new MemorySaver()); // å¾…é˜…è¯» // ç”Ÿå‘½å‘¨æœŸç›‘å¬å™¨é˜Ÿåˆ— private Deque\u0026lt;GraphLifecycleListener\u0026gt; lifecycleListeners = new LinkedBlockingDeque\u0026lt;\u0026gt;(25); // ä¸­æ–­ç‚¹é…ç½® private Set\u0026lt;String\u0026gt; interruptsBefore = Set.of(); // èŠ‚ç‚¹æ‰§è¡Œå‰ä¸­æ–­ private Set\u0026lt;String\u0026gt; interruptsAfter = Set.of(); // èŠ‚ç‚¹æ‰§è¡Œåä¸­æ–­ // çº¿ç¨‹é‡Šæ”¾æ ‡å¿— private boolean releaseThread = false; } ä¸€èˆ¬é…ç½®ç”¨æ³•ï¼š\n1 2 3 4 5 6 7 8 CompileConfig config = CompileConfig.builder() .interruptBefore(\u0026#34;node1\u0026#34;, \u0026#34;node2\u0026#34;) // åœ¨node1å’Œnode2å‰ä¸­æ–­ .interruptAfter(\u0026#34;node3\u0026#34;) // åœ¨node3åä¸­æ–­ .withLifecycleListener(listener) // æ·»åŠ ç”Ÿå‘½å‘¨æœŸç›‘å¬å™¨ .releaseThread(true) // å¯ç”¨çº¿ç¨‹é‡Šæ”¾ .build(); CompiledGraph graph = stateGraph.compile(config); 7.2 RunnableConfig ä¸»è¦ç”¨äºåœ¨å›¾æ‰§è¡Œè¿‡ç¨‹ä¸­ä¼ é€’è¿è¡Œæ—¶å‚æ•°ã€‚\nthreadId: çº¿ç¨‹æ ‡è¯†ç¬¦ï¼Œç”¨äºå¤šçº¿ç¨‹åœºæ™¯\ncheckPointId: æ£€æŸ¥ç‚¹IDï¼Œç”¨äºçŠ¶æ€æ¢å¤\nnextNode: æŒ‡å®šä¸‹ä¸€ä¸ªè¦æ‰§è¡Œçš„èŠ‚ç‚¹\nstreamMode: æµæ¨¡å¼é…ç½®\nmetadata: è‡ªå®šä¹‰å…ƒæ•°æ®\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public final class RunnableConfig implements HasMetadata\u0026lt;RunnableConfig.Builder\u0026gt; { private final String threadId; private final String checkPointId; private final String nextNode; private final CompiledGraph.StreamMode streamMode; private final Map\u0026lt;String, Object\u0026gt; metadata; public CompiledGraph.StreamMode streamMode() { return streamMode; } public Optional\u0026lt;String\u0026gt; threadId() { return ofNullable(threadId); } public Optional\u0026lt;String\u0026gt; checkPointId() { return ofNullable(checkPointId); } public Optional\u0026lt;String\u0026gt; nextNode() { return ofNullable(nextNode); } public RunnableConfig withStreamMode(CompiledGraph.StreamMode streamMode) { if (this.streamMode == streamMode) { return this; } return RunnableConfig.builder(this).streamMode(streamMode).build(); } public RunnableConfig withCheckPointId(String checkPointId) { if (Objects.equals(this.checkPointId, checkPointId)) { return this; } return RunnableConfig.builder(this).checkPointId(checkPointId).build(); } ä¸€èˆ¬é…ç½®ç”¨æ³•ï¼š\n1 2 3 4 5 6 7 8 9 RunnableConfig runConfig = RunnableConfig.builder() .threadId(\u0026#34;thread-001\u0026#34;) .checkPointId(\u0026#34;checkpoint-123\u0026#34;) .nextNode(\u0026#34;startNode\u0026#34;) .streamMode(CompiledGraph.StreamMode.VALUES) .addMetadata(\u0026#34;userId\u0026#34;, \u0026#34;user123\u0026#34;) .build(); graph.invoke(initialState, runConfig); 7.3 ActionWithConfig ä¸»è¦ä½œç”¨å°±æ˜¯å…è®¸Actionåœ¨è¿è¡Œæ—¶è®¿é—®RunnableConfigã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public interface AsyncNodeActionWithConfig extends BiFunction\u0026lt;OverAllState, RunnableConfig, CompletableFuture\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt;\u0026gt; { /** * Applies this action to the given agent state. * @param state the agent state * @return a CompletableFuture representing the result of the action */ CompletableFuture\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; apply(OverAllState state, RunnableConfig config); static AsyncNodeActionWithConfig node_async(NodeActionWithConfig syncAction) { return (state, config) -\u0026gt; { CompletableFuture\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; result = new CompletableFuture\u0026lt;\u0026gt;(); try { result.complete(syncAction.apply(state, config)); } catch (Exception e) { result.completeExceptionally(e); } return result; }; } /** * Adapts a simple AsyncNodeAction to an AsyncNodeActionWithConfig. * @param action the simple AsyncNodeAction to be adapted * @return an AsyncNodeActionWithConfig that wraps the given AsyncNodeAction */ static AsyncNodeActionWithConfig of(AsyncNodeAction action) { return (t, config) -\u0026gt; action.apply(t); } } 8 CompiledGraph CompiledGraphæ˜¯Graphæ¡†æ¶çš„æ ¸å¿ƒï¼Œæä¾›äº†ä»¥ä¸‹åŠŸèƒ½ï¼š\nå›¾ç¼–è¯‘: å°†StateGraphè½¬æ¢ä¸ºå¯æ‰§è¡Œç»“æ„ æµå¼æ‰§è¡Œ: æ”¯æŒå¼‚æ­¥æµå¼å¤„ç† çŠ¶æ€ç®¡ç†: å®Œæ•´çš„çŠ¶æ€å†å²å’Œæ£€æŸ¥ç‚¹æœºåˆ¶ ä¸­æ–­æ§åˆ¶: æ”¯æŒæ‰§è¡Œå‰åçš„ä¸­æ–­ç‚¹ ç”Ÿå‘½å‘¨æœŸç®¡ç†: å®Œæ•´çš„æ‰§è¡Œç”Ÿå‘½å‘¨æœŸç›‘å¬ å­å›¾æ”¯æŒ: é€’å½’å¤„ç†å­å›¾ç»“æ„ å¼‚å¸¸å¤„ç†: å®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶ 8.1 æ ¸å¿ƒå±æ€§ 1 2 3 4 5 6 7 public final StateGraph stateGraph; // çŠ¶æ€å›¾ private final Map\u0026lt;String, KeyStrategy\u0026gt; keyStrategyMap; // é”®ç­–ç•¥æ˜ å°„ final Map\u0026lt;String, AsyncNodeActionWithConfig\u0026gt; nodes; // èŠ‚ç‚¹æ˜ å°„ final Map\u0026lt;String, EdgeValue\u0026gt; edges; // è¾¹æ˜ å°„ private final ProcessedNodesEdgesAndConfig processedData; // å¤„ç†åçš„èŠ‚ç‚¹å’Œè¾¹é…ç½® private int maxIterations = 25; // æœ€å¤§è¿­ä»£æ¬¡æ•° public final CompileConfig compileConfig; // ç¼–è¯‘é…ç½® 8.2 çŠ¶æ€æµè½¬é€»è¾‘ 8.2.1 æµå¼æ¨¡å¼ 8.2.1.1 å…¥å£æ¥å£ ä»¥DeepResearchçš„å®ç°ä¸ºä¾‹å­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 @RequestMapping(value = \u0026#34;/chat/stream\u0026#34;, method = RequestMethod.POST, produces = MediaType.TEXT_EVENT_STREAM_VALUE) public Flux\u0026lt;ServerSentEvent\u0026lt;String\u0026gt;\u0026gt; chatStream(@RequestBody(required = false) ChatRequest chatRequest) throws GraphRunnerException { //... else { ChatRequestProcess.initializeObjectMap(chatRequest, objectMap); logger.info(\u0026#34;init inputs: {}\u0026#34;, objectMap); AsyncGenerator\u0026lt;NodeOutput\u0026gt; resultFuture = compiledGraph.stream(objectMap, runnableConfig); graphProcess.processStream(resultFuture, sink); } } è¿™æ˜¯ä¸€ä¸ªControlleræ¥å£ï¼Œå¯ä»¥çœ‹åˆ°ï¼Œå›¾æ˜¯ä»è¿™ä¸ªæ–¹æ³•è¿›å»çš„compiledGraph.stream(objectMap, runnableConfig);ã€‚\næˆ‘ä»¬æ¥çœ‹çœ‹å…·ä½“å®ç°ï¼š\n1 2 3 4 5 public AsyncGenerator\u0026lt;NodeOutput\u0026gt; stream(Map\u0026lt;String, Object\u0026gt; inputs, RunnableConfig config) throws GraphRunnerException { Objects.requireNonNull(config, \u0026#34;config cannot be null\u0026#34;); final AsyncNodeGenerator\u0026lt;NodeOutput\u0026gt; generator = new AsyncNodeGenerator\u0026lt;\u0026gt;(stateCreate(inputs), config); return new AsyncGenerator.WithEmbed\u0026lt;\u0026gt;(generator); } è¿™ä¸ªåœ°æ–¹è¿”å›äº†ä¸€ä¸ªAsyncGenerator.WithEmbedï¼Œè¿™ç©æ„æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ\nç®€è€Œè¨€ä¹‹ï¼Œè¿™ä¸ªä¸œè¥¿æ˜¯ä¸€ä¸ªå…è®¸å…¶ä»–çš„AsyncGeneratoråœ¨å…¶æ‰§è¡Œè¿‡ç¨‹ä¸­æ‰§è¡Œçš„åŒ…è£…ç±»ã€‚\næ‰§è¡Œæµç¨‹æ˜¯ï¼š\nä»å †æ ˆé¡¶éƒ¨è·å–å½“å‰ç”Ÿæˆå™¨\nè°ƒç”¨å½“å‰ç”Ÿæˆå™¨çš„next()æ–¹æ³•è·å–ç»“æœ\nå¦‚æœç»“æœè¡¨ç¤ºç”Ÿæˆå™¨å·²å®Œæˆï¼š\næ¸…é™¤ä¹‹å‰çš„è¿”å›å€¼ï¼ˆå¦‚æœæœ‰ï¼‰\nå°†ç»“æœæ¨å…¥è¿”å›å€¼å †æ ˆ\næ‰§è¡Œå®Œæˆå›è°ƒï¼ˆå¦‚æœæœ‰ï¼‰\nå¦‚æœè¿™æ˜¯æœ€åä¸€ä¸ªç”Ÿæˆå™¨ï¼Œè¿”å›ç»“æœ\nå¦åˆ™ï¼Œå¼¹å‡ºå½“å‰ç”Ÿæˆå™¨ï¼Œé€’å½’è°ƒç”¨next()ç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ªç”Ÿæˆå™¨\nå¦‚æœç»“æœåŒ…å«ä¸€ä¸ªåµŒå…¥ç”Ÿæˆå™¨ï¼š æ£€æŸ¥åµŒå¥—æ·±åº¦ï¼ˆç›®å‰ä¸æ”¯æŒé€’å½’åµŒå¥—ï¼‰\nå°†åµŒå…¥ç”Ÿæˆå™¨æ¨å…¥å †æ ˆ\né€’å½’è°ƒç”¨next()å¤„ç†åµŒå…¥ç”Ÿæˆå™¨\nå¦åˆ™ï¼Œç›´æ¥è¿”å›ç»“æœ çœ‹çœ‹å…·ä½“å®ç°ï¼š\n1 2 protected final Deque\u0026lt;Embed\u0026lt;E\u0026gt;\u0026gt; generatorsStack = new ArrayDeque\u0026lt;\u0026gt;(2); private final Deque\u0026lt;Data\u0026lt;E\u0026gt;\u0026gt; returnValueStack = new ArrayDeque\u0026lt;\u0026gt;(2); é¦–å…ˆæ ¸å¿ƒæ•°æ®ç»“æ„æ˜¯åˆ©ç”¨è¿™ä¸¤ä¸ªåŒç«¯é˜Ÿåˆ—ç»´æŠ¤è¿”å›å€¼å’Œç”Ÿæˆå™¨æ ˆã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @Override public Data\u0026lt;E\u0026gt; next() { if (generatorsStack.isEmpty()) { // GUARD throw new IllegalStateException(\u0026#34;no generator found!\u0026#34;); } final Embed\u0026lt;E\u0026gt; embed = generatorsStack.peek(); final Data\u0026lt;E\u0026gt; result = embed.generator.next(); if (result.isDone()) { clearPreviousReturnsValuesIfAny(); returnValueStack.push(result); if (embed.onCompletion != null) { try { embed.onCompletion.accept(result.resultValue); } catch (Exception e) { return Data.error(e); } } if (isLastGenerator()) { return result; } generatorsStack.pop(); return next(); } if (result.embed != null) { if (generatorsStack.size() \u0026gt;= 2) { return Data.error(new UnsupportedOperationException( \u0026#34;Currently recursive nested generators are not supported!\u0026#34;)); } generatorsStack.push(result.embed); return next(); } return result; } è¿™ä¸ªæ–¹æ³•æ˜¯æ ¸å¿ƒæ–¹æ³•ï¼Œé€’å½’åœ°å¤„ç†äº†åµŒå…¥çš„ç”Ÿæˆå™¨ã€‚\nåœ¨çŠ¶æ€æµè½¬ä¸­ï¼Œå¤„ç†åµŒå…¥çš„Generatorçš„é€»è¾‘å¦‚ä¸‹ï¼š\nä¸»AsyncNodeGenerator â†’ å‘ç°åµŒå…¥ç”Ÿæˆå™¨ â†’ WithEmbedæ¥ç®¡ â†’ æ‰§è¡ŒåµŒå…¥ç”Ÿæˆå™¨ â†’ å®Œæˆåæ¢å¤ â†’ ä¸»AsyncNodeGeneratorç»§ç»­\n8.2.1.2 çŠ¶æ€æµè½¬ AsyncNodeGeneratoræ˜¯æ•´ä¸ªå›¾æµè½¬æ‰§è¡Œçš„å”¯ä¸€çŠ¶æ€æœºï¼Œ\nç„¶åæˆ‘ä»¬æ¥çœ‹çœ‹AsyncNodeGeneratorçš„å®ç°ï¼š\næ ¸å¿ƒæ–¹æ³•æ˜¯nextï¼Œå…¶å®ç°äº†çŠ¶æ€å›¾æµè½¬ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @Override public Data\u0026lt;o\u0026gt; next() { try { // æ£€æŸ¥æœ€å¤§è¿­ä»£æ¬¡æ•° if (++iteration \u0026gt; maxIterations) { return Data.error(new IllegalStateException( format(\u0026#34;Maximum number of iterations (%d) reached!\u0026#34;, maxIterations))); } // æ£€æŸ¥æ˜¯å¦å·²ç»“æŸ if (nextNodeId == null \u0026amp;\u0026amp; currentNodeId == null) { return releaseThread().map(Data::\u0026lt;o\u0026gt;done).orElseGet(() -\u0026gt; Data.done(currentState)); } // æ˜¯å¦ä»åµŒå…¥æ¢å¤ if (resumedFromEmbed) { final CompletableFuture\u0026lt;o\u0026gt; future = getNodeOutput(); resumedFromEmbed = false; return Data.of(future); } // å¤„ç†STARTèŠ‚ç‚¹ if (START.equals(currentNodeId)) { doListeners(START, null); var nextNodeCommand = getEntryPoint(currentState, config); nextNodeId = nextNodeCommand.gotoNode(); currentState = nextNodeCommand.update(); var cp = addCheckpoint(config, START, currentState, nextNodeId); var output = (cp.isPresent() \u0026amp;\u0026amp; config.streamMode() == StreamMode.SNAPSHOTS) ? buildStateSnapshot(cp.get()) : buildNodeOutput(currentNodeId); currentNodeId = nextNodeId; return Data.of(output); } // å¤„ç†ENDèŠ‚ç‚¹ if (END.equals(nextNodeId)) { nextNodeId = null; currentNodeId = null; doListeners(END, null); return Data.of(buildNodeOutput(END)); } // æ£€æŸ¥ä¸­æ–­æ¡ä»¶ if (shouldInterruptAfter(currentNodeId, nextNodeId)) { return Data.done(currentNodeId); } if (shouldInterruptBefore(nextNodeId, currentNodeId)) { return Data.done(currentNodeId); } // æ›´æ–°å½“å‰èŠ‚ç‚¹ID currentNodeId = nextNodeId; // è·å–å½“å‰èŠ‚ç‚¹å¯¹åº”çš„åŠ¨ä½œ var action = nodes.get(currentNodeId); if (action == null) throw RunnableErrors.missingNode.exception(currentNodeId); // æ‰§è¡ŒèŠ‚ç‚¹åŠ¨ä½œ return evaluateAction(action, this.overAllState).get(); } catch (Exception e) { doListeners(ERROR, e); log.error(e.getMessage(), e); return Data.error(e); } } å…¶ä¸­evaluateActionæ‰§è¡Œäº†nodeActionï¼Œä»£ç å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 private Command nextNodeId(String nodeId, OverAllState overAllState, Map\u0026lt;String, Object\u0026gt; state, RunnableConfig config) throws Exception { EdgeValue route = edges.get(nodeId); if (route == null) { throw RunnableErrors.missingEdge.exception(nodeId); } // å¦‚æœè¾¹æœ‰å›ºå®šçš„ç›®æ ‡ID if (route.id() != null) { return new Command(route.id(), state); } // å¦‚æœè¾¹æœ‰æ¡ä»¶é€»è¾‘ if (route.value() != null) { // æ‰§è¡Œè¾¹çš„æ¡ä»¶åŠ¨ä½œ var command = route.value().action().apply(overAllState, config).get(); var newRoute = command.gotoNode(); // æ ¹æ®æ¡ä»¶ç»“æœæŸ¥æ‰¾æ˜ å°„çš„ç›®æ ‡èŠ‚ç‚¹ String result = route.value().mappings().get(newRoute); if (result == null) { throw RunnableErrors.missingNodeInEdgeMapping.exception(nodeId, newRoute); } // æ›´æ–°çŠ¶æ€ var currentState = OverAllState.updateState(state, command.update(), keyStrategyMap); overAllState.updateState(command.update()); return new Command(result, currentState); } throw RunnableErrors.executionError.exception(format(\u0026#34;invalid edge value for nodeId: [%s] !\u0026#34;, nodeId)); } ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ç”±nextNodeIdæ–¹æ³•å†³å®šï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 private Command nextNodeId(String nodeId, OverAllState overAllState, Map\u0026lt;String, Object\u0026gt; state, RunnableConfig config) throws Exception { EdgeValue route = edges.get(nodeId); if (route == null) { throw RunnableErrors.missingEdge.exception(nodeId); } // å¦‚æœè¾¹æœ‰å›ºå®šçš„ç›®æ ‡ID if (route.id() != null) { return new Command(route.id(), state); } // å¦‚æœè¾¹æœ‰æ¡ä»¶é€»è¾‘ if (route.value() != null) { // æ‰§è¡Œè¾¹çš„æ¡ä»¶åŠ¨ä½œ var command = route.value().action().apply(overAllState, config).get(); var newRoute = command.gotoNode(); // æ ¹æ®æ¡ä»¶ç»“æœæŸ¥æ‰¾æ˜ å°„çš„ç›®æ ‡èŠ‚ç‚¹ String result = route.value().mappings().get(newRoute); if (result == null) { throw RunnableErrors.missingNodeInEdgeMapping.exception(nodeId, newRoute); } // æ›´æ–°çŠ¶æ€ var currentState = OverAllState.updateState(state, command.update(), keyStrategyMap); overAllState.updateState(command.update()); return new Command(result, currentState); } throw RunnableErrors.executionError.exception(format(\u0026#34;invalid edge value for nodeId: [%s] !\u0026#34;, nodeId)); } 8.2.1.3 å¹¶è¡ŒèŠ‚ç‚¹ é¦–å…ˆï¼Œç¼–è¯‘æ—¶ä¼šæ£€æµ‹è¾¹çš„targetæ•°é‡ï¼Œå‘ç°æœ‰å¹¶è¡Œè¾¹ä»¥åå°±åˆ›å»ºå¹¶è¡ŒèŠ‚ç‚¹å¹¶æ›¿æ¢å›¾ç»“æ„ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 for (var e : processedData.edges().elements) { var targets = e.targets(); if (targets.size() == 1) { edges.put(e.sourceId(), targets.get(0)); // å•ä¸€ç›®æ ‡ï¼Œæ­£å¸¸å¤„ç† } else { // å‘ç°å¤šä¸ªç›®æ ‡ï¼Œå¤„ç†å¹¶è¡Œåˆ†æ”¯ Supplier\u0026lt;Stream\u0026lt;EdgeValue\u0026gt;\u0026gt; parallelNodeStream = () -\u0026gt; targets.stream() .filter(target -\u0026gt; nodes.containsKey(target.id())); // éªŒè¯å¹¶è¡Œåˆ†æ”¯çš„åˆæ³•æ€§ var parallelNodeTargets = parallelNodeEdges.stream() .map(ee -\u0026gt; ee.target().id()) .collect(Collectors.toSet()); if (parallelNodeTargets.size() \u0026gt; 1) { // æ£€æŸ¥æ¡ä»¶è¾¹ - å¹¶è¡Œåˆ†æ”¯ä¸å…è®¸æ¡ä»¶è¾¹ var conditionalEdges = parallelNodeEdges.stream() .filter(ee -\u0026gt; ee.target().value() != null) .toList(); if (!conditionalEdges.isEmpty()) { throw Errors.unsupportedConditionalEdgeOnParallelNode.exception(...); } // æ£€æŸ¥å¤šç›®æ ‡ - æ‰€æœ‰åˆ†æ”¯å¿…é¡»æ±‡èšåˆ°åŒä¸€ä¸ªèŠ‚ç‚¹ throw Errors.illegalMultipleTargetsOnParallelNode.exception(...); } // åˆ›å»ºParallelNode var actions = parallelNodeStream.get() .map(target -\u0026gt; nodes.get(target.id())) // æ”¶é›†æ‰€æœ‰åˆ†æ”¯çš„Action .toList(); var parallelNode = new ParallelNode(e.sourceId(), actions, keyStrategyMap); // æ›¿æ¢å›¾ç»“æ„ nodes.put(parallelNode.id(), parallelNode.actionFactory().apply(compileConfig)); edges.put(e.sourceId(), new EdgeValue(parallelNode.id())); // åŸèŠ‚ç‚¹ â†’ ParallelNode edges.put(parallelNode.id(), new EdgeValue(parallelNodeTargets.iterator().next())); // ParallelNode â†’ æ±‡èšèŠ‚ç‚¹ } } è¿è¡Œæ—¶ï¼ŒParallelNodeæ‰§è¡Œé€»è¾‘å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @Override public CompletableFuture\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; apply(OverAllState state, RunnableConfig config) { Map\u0026lt;String, Object\u0026gt; partialMergedStates = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;String, Object\u0026gt; asyncGenerators = new HashMap\u0026lt;\u0026gt;(); // åˆ›å»ºæ‰€æœ‰åˆ†æ”¯çš„å¹¶è¡Œæ‰§è¡Œä»»åŠ¡ var futures = actions.stream().map(action -\u0026gt; action.apply(state, config).thenApply(partialState -\u0026gt; { partialState.forEach((key, value) -\u0026gt; { if (value instanceof AsyncGenerator\u0026lt;?\u0026gt; || value instanceof GeneratorSubscriber) { // AsyncGeneratorç±»å‹ â†’ æ”¾å…¥å¼‚æ­¥ç”Ÿæˆå™¨é›†åˆ ((List) asyncGenerators.computeIfAbsent(key, k -\u0026gt; new ArrayList\u0026lt;\u0026gt;())).add(value); } else { // æ™®é€šå€¼ â†’ æ”¾å…¥çŠ¶æ€åˆå¹¶é›†åˆ partialMergedStates.put(key, value); } }); state.updateState(partialMergedStates); // ç«‹å³æ›´æ–°çŠ¶æ€ return action; }) ).toList().toArray(new CompletableFuture[0]); // ç­‰å¾…æ‰€æœ‰åˆ†æ”¯å®Œæˆ return CompletableFuture.allOf(futures) .thenApply((p) -\u0026gt; CollectionUtils.isEmpty(asyncGenerators) ? state.data() : // æ²¡æœ‰AsyncGeneratorï¼Œè¿”å›åˆå¹¶çŠ¶æ€ asyncGenerators); // æœ‰AsyncGeneratorï¼Œè§¦å‘åµŒå…¥æœºåˆ¶ } æ­¤æ—¶ï¼Œä¼šè¢«evaluateActionçš„thenApplyå›è°ƒæ‰€å¤„ç†ï¼Œç”±äºè¿”å›äº†AsnycGeneratorï¼Œä¼šè¿›å…¥getEmbedGeneratorè¿›è¡Œå¤„ç†ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 return action.apply(withState, config).thenApply(updateState -\u0026gt; { try { // updateState å°±æ˜¯NodeActionè¿”å›çš„Map\u0026lt;String,Object\u0026gt; // 1. ç‰¹æ®Šå¤„ç†ï¼šCommandNode ... // 2. æ£€æŸ¥åµŒå…¥ç”Ÿæˆå™¨ Optional\u0026lt;Data\u0026lt;o\u0026gt;\u0026gt; embed = getEmbedGenerator(updateState); if (embed.isPresent()) { return embed.get(); // è§¦å‘åµŒå…¥ç”Ÿæˆå™¨å¤„ç† } // 3. å¸¸è§„çŠ¶æ€æ›´æ–° ... // 4. è®¡ç®—ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ ... } catch (Exception e) { throw new CompletionException(e); } }); æ¥çœ‹çœ‹getEmbedGeneratorçš„å®ç°ï¼š\nè¿™é‡Œä¸»è¦åšäº†ä¸¤ä»¶äº‹ï¼š1. çœ‹partialStateé‡Œé¢æœ‰å‡ ä¸ªembedGenerator 2. å¦‚æœæœ‰å¤šä¸ªï¼Œå°±åˆå¹¶æˆä¸€ä¸ªã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 private Optional\u0026lt;Data\u0026lt;Output\u0026gt;\u0026gt; getEmbedGenerator(Map\u0026lt;String, Object\u0026gt; partialState) { // Extract all AsyncGenerator instances List\u0026lt;AsyncGenerator\u0026lt;Output\u0026gt;\u0026gt; asyncNodeGenerators = new ArrayList\u0026lt;\u0026gt;(); var generatorEntries = partialState.entrySet().stream().filter(e -\u0026gt; { // Fixed when parallel nodes return asynchronous generating the same key Object value = e.getValue(); if (value instanceof AsyncGenerator) { return true; } if (value instanceof Collection collection) { collection.forEach(o -\u0026gt; { if (o instanceof AsyncGenerator\u0026lt;?\u0026gt;) { asyncNodeGenerators.add((AsyncGenerator\u0026lt;Output\u0026gt;) o); } }); } return false; }).collect(Collectors.toList()); if (generatorEntries.isEmpty() \u0026amp;\u0026amp; asyncNodeGenerators.isEmpty()) { return Optional.empty(); } // Log information about found generators if (generatorEntries.size() \u0026gt; 1) { log.debug(\u0026#34;Multiple generators found: {} - keys: {}\u0026#34;, generatorEntries.size(), generatorEntries.stream().map(Map.Entry::getKey).collect(Collectors.joining(\u0026#34;, \u0026#34;))); } // Create appropriate generator (single or merged) AsyncGenerator\u0026lt;Output\u0026gt; generator = AsyncGeneratorUtils.createAppropriateGenerator(generatorEntries, asyncNodeGenerators, keyStrategyMap); // Create data processing logic for the generator return Optional.of(Data.composeWith(generator.map(n -\u0026gt; { n.setSubGraph(true); return n; }), data -\u0026gt; processGeneratorOutput(data, partialState, generatorEntries))); } æ¥çœ‹çœ‹åˆå¹¶Generatorçš„ä»£ç å…·ä½“å®ç°ï¼š\nè¿™å¯èƒ½çœ‹èµ·æ¥å¾ˆå¤æ‚ï¼Œä¸»è¦å°±æ˜¯è¿”å›äº†ä¸€ä¸ªæ–°çš„AsnycGeneratorï¼Œå®ƒå¯ä»¥è½®è¯¢æ‰§è¡Œæ‰€æœ‰è¾“å…¥çš„ç”Ÿæˆå™¨ã€‚\nåŒæ—¶ï¼Œè¿™ä¸ªAsnycGeneratorå¯èƒ½è¢«å¹¶å‘è®¿é—®ï¼Œæ•…éœ€è¦åŠ é”ã€‚\næ‰§è¡Œè·¯å¾„ï¼š\nä½¿ç”¨ä¹è§‚é”æ£€æŸ¥æ˜¯å¦å·²ç»mergeå®Œæˆï¼Œå¦‚æœæœ‰çº¿ç¨‹è·å–å†™é”ï¼Œå°±è·å–æ‚²è§‚è¯»é”è¯»å–éªŒè¯ã€‚ å¼€å§‹mergeï¼Œé¦–å…ˆè·å–å†™é”ï¼Œä¿è¯è½®è¯¢ç¬¦åˆæ“ä½œçš„åŸå­æ€§ã€‚ é‡Šæ”¾å†™é”ï¼Œæ— é”ä¸‹æ‰§è¡Œnextæ–¹æ³•è·å–å•ä¸ªç»“æœï¼Œç”±äºå‰é¢ä¿è¯äº†è·å–çš„ä¸æ˜¯åŒä¸€ä¸ªgeneratorï¼Œæ‰€ä»¥è¿™é‡Œæ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚ å†æ¬¡è·å–å†™é”ï¼Œæ›´æ–°çŠ¶æ€ï¼Œä¿è¯activeGenerators â†” mergedResult â†” generatorResultsçš„çŠ¶æ€ä¸€è‡´æ€§ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 public static \u0026lt;T\u0026gt; AsyncGenerator\u0026lt;T\u0026gt; createMergedGenerator(List\u0026lt;AsyncGenerator\u0026lt;T\u0026gt;\u0026gt; generators, Map\u0026lt;String, KeyStrategy\u0026gt; keyStrategyMap) { return new AsyncGenerator\u0026lt;\u0026gt;() { // Switch to StampedLock to simplify lock management private final StampedLock lock = new StampedLock(); private AtomicInteger pollCounter = new AtomicInteger(0); private Map\u0026lt;String, Object\u0026gt; mergedResult = new HashMap\u0026lt;\u0026gt;(); private final List\u0026lt;AsyncGenerator\u0026lt;T\u0026gt;\u0026gt; activeGenerators = new CopyOnWriteArrayList\u0026lt;\u0026gt;(generators); private final Map\u0026lt;AsyncGenerator\u0026lt;T\u0026gt;, Map\u0026lt;String, Object\u0026gt;\u0026gt; generatorResults = new HashMap\u0026lt;\u0026gt;(); @Override public AsyncGenerator.Data\u0026lt;T\u0026gt; next() { while (true) { // Read optimistically and check quickly long stamp = lock.tryOptimisticRead(); boolean empty = activeGenerators.isEmpty(); if (!lock.validate(stamp)) { stamp = lock.readLock(); try { empty = activeGenerators.isEmpty(); } finally { lock.unlockRead(stamp); } } if (empty) { return AsyncGenerator.Data.done(mergedResult); } // Fine-grained lock control final int currentIdx; AsyncGenerator\u0026lt;T\u0026gt; current; long writeStamp = lock.writeLock(); try { final int size = activeGenerators.size(); if (size == 0) return AsyncGenerator.Data.done(mergedResult); currentIdx = pollCounter.updateAndGet(i -\u0026gt; (i + 1) % size); current = activeGenerators.get(currentIdx); } finally { lock.unlockWrite(writeStamp); } // Execute the generator \u0026#39;next()\u0026#39; in the unlocked state AsyncGenerator.Data\u0026lt;T\u0026gt; data = current.next(); writeStamp = lock.writeLock(); try { // Double checks prevent status changes if (!activeGenerators.contains(current)) { continue; } if (data.isDone() || data.isError()) { handleCompletedGenerator(current, data); if (activeGenerators.isEmpty()) { return AsyncGenerator.Data.done(mergedResult); } continue; } handleCompletedGenerator(current, data); return data; } finally { lock.unlockWrite(writeStamp); } } } /** * Helper method to handle completed or errored generators */ private void handleCompletedGenerator(AsyncGenerator\u0026lt;T\u0026gt; generator, AsyncGenerator.Data\u0026lt;T\u0026gt; data) { // Remove generator if done or error if (data.isDone() || data.isError()) { activeGenerators.remove(generator); } // Process result if exists data.resultValue().ifPresent(result -\u0026gt; { if (result instanceof Map) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) Map\u0026lt;String, Object\u0026gt; mapResult = (Map\u0026lt;String, Object\u0026gt;) result; mergedResult = OverAllState.updateState(mergedResult, mapResult, keyStrategyMap); } }); // Remove from generator results if present generatorResults.remove(generator); } }; } 8.2.2 AsyncGenerator æ–½å·¥ä¸­ã€‚ã€‚ã€‚\n8.3 GraphLifeCycleLister æš´éœ²çš„é’©å­å‡½æ•°ï¼Œå¯ä»¥é€šè¿‡é…ç½®Listeré˜Ÿåˆ—æ¥åœ¨å›¾çš„ä¸åŒçŠ¶æ€è§¦å‘è‡ªå®šä¹‰å‡½æ•°ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 private void doListeners(String scene, Exception e) { Deque\u0026lt;GraphLifecycleListener\u0026gt; listeners = new LinkedBlockingDeque\u0026lt;\u0026gt;(compileConfig.lifecycleListeners()); processListenersLIFO(listeners, scene, e); } private void processListenersLIFO(Deque\u0026lt;GraphLifecycleListener\u0026gt; listeners, String scene, Exception e) { if (listeners.isEmpty()) { return; } GraphLifecycleListener listener = listeners.pollLast(); try { if (START.equals(scene)) { listener.onStart(START, this.currentState); } else if (END.equals(scene)) { listener.onComplete(END, this.currentState); } else if (ERROR.equals(scene)) { listener.onError(this.currentNodeId, this.currentState, e); } processListenersLIFO(listeners, scene, e); } catch (Exception ex) { log.debug(\u0026#34;Error occurred during listener processing: {}\u0026#34;, ex.getMessage()); } } 8.4 å­å›¾å¤„ç† ä¸»è¦å®ç°äº†ï¼š\næŠŠå­å›¾çš„èŠ‚ç‚¹å’Œè¾¹å«æ¥åˆ°ä¸»å›¾ä¸Šé¢ï¼Œç„¶åè¿”å›ä¿®æ”¹åçš„ä¸»å›¾ã€‚\næŠŠå­å›¾ä¸­æ–­è½¬ç§»åˆ°å­å›¾å…¥å£ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 record ProcessedNodesEdgesAndConfig(StateGraph.Nodes nodes, StateGraph.Edges edges, Set\u0026lt;String\u0026gt; interruptsBefore, Set\u0026lt;String\u0026gt; interruptsAfter) { /** * Instantiates a new Processed nodes edges and config. * @param stateGraph the state graph * @param config the config */ ProcessedNodesEdgesAndConfig(StateGraph stateGraph, CompileConfig config) { this(stateGraph.nodes, stateGraph.edges, config.interruptsBefore(), config.interruptsAfter()); } /** * Process processed nodes edges and config. * @param stateGraph the state graph * @param config the config * @return the processed nodes edges and config * @throws GraphStateException the graph state exception */ static ProcessedNodesEdgesAndConfig process(StateGraph stateGraph, CompileConfig config) throws GraphStateException { var subgraphNodes = stateGraph.nodes.onlySubStateGraphNodes(); if (subgraphNodes.isEmpty()) { return new ProcessedNodesEdgesAndConfig(stateGraph, config); } var interruptsBefore = config.interruptsBefore(); var interruptsAfter = config.interruptsAfter(); var nodes = new StateGraph.Nodes(stateGraph.nodes.exceptSubStateGraphNodes()); var edges = new StateGraph.Edges(stateGraph.edges.elements); for (var subgraphNode : subgraphNodes) { var sgWorkflow = subgraphNode.subGraph(); // // Process START Node // var sgEdgeStart = sgWorkflow.edges.edgeBySourceId(START).orElseThrow(); if (sgEdgeStart.isParallel()) { throw new GraphStateException(\u0026#34;subgraph not support start with parallel branches yet!\u0026#34;); } var sgEdgeStartTarget = sgEdgeStart.target(); if (sgEdgeStartTarget.id() == null) { throw new GraphStateException(format(\u0026#34;the target for node \u0026#39;%s\u0026#39; is null!\u0026#34;, subgraphNode.id())); } var sgEdgeStartRealTargetId = subgraphNode.formatId(sgEdgeStartTarget.id()); // Process Interruption (Before) Subgraph(s) interruptsBefore = interruptsBefore.stream() .map(interrupt -\u0026gt; Objects.equals(subgraphNode.id(), interrupt) ? sgEdgeStartRealTargetId : interrupt) .collect(Collectors.toUnmodifiableSet()); var edgesWithSubgraphTargetId = edges.edgesByTargetId(subgraphNode.id()); if (edgesWithSubgraphTargetId.isEmpty()) { throw new GraphStateException( format(\u0026#34;the node \u0026#39;%s\u0026#39; is not present as target in graph!\u0026#34;, subgraphNode.id())); } for (var edgeWithSubgraphTargetId : edgesWithSubgraphTargetId) { var newEdge = edgeWithSubgraphTargetId.withSourceAndTargetIdsUpdated(subgraphNode, Function.identity(), id -\u0026gt; new EdgeValue((Objects.equals(id, subgraphNode.id()) ? subgraphNode.formatId(sgEdgeStartTarget.id()) : id))); edges.elements.remove(edgeWithSubgraphTargetId); edges.elements.add(newEdge); } // // Process END Nodes // var sgEdgesEnd = sgWorkflow.edges.edgesByTargetId(END); var edgeWithSubgraphSourceId = edges.edgeBySourceId(subgraphNode.id()).orElseThrow(); if (edgeWithSubgraphSourceId.isParallel()) { throw new GraphStateException(\u0026#34;subgraph not support routes to parallel branches yet!\u0026#34;); } // Process Interruption (After) Subgraph(s) if (interruptsAfter.contains(subgraphNode.id())) { var exceptionMessage = (edgeWithSubgraphSourceId.target() .id() == null) ? \u0026#34;\u0026#39;interruption after\u0026#39; on subgraph is not supported yet!\u0026#34; : format( \u0026#34;\u0026#39;interruption after\u0026#39; on subgraph is not supported yet! consider to use \u0026#39;interruption before\u0026#39; node: \u0026#39;%s\u0026#39;\u0026#34;, edgeWithSubgraphSourceId.target().id()); throw new GraphStateException(exceptionMessage); } sgEdgesEnd.stream() .map(e -\u0026gt; e.withSourceAndTargetIdsUpdated(subgraphNode, subgraphNode::formatId, id -\u0026gt; (Objects.equals(id, END) ? edgeWithSubgraphSourceId.target() : new EdgeValue(subgraphNode.formatId(id))))) .forEach(edges.elements::add); edges.elements.remove(edgeWithSubgraphSourceId); // // Process edges // sgWorkflow.edges.elements.stream() .filter(e -\u0026gt; !Objects.equals(e.sourceId(), START)) .filter(e -\u0026gt; !e.anyMatchByTargetId(END)) .map(e -\u0026gt; e.withSourceAndTargetIdsUpdated(subgraphNode, subgraphNode::formatId, id -\u0026gt; new EdgeValue(subgraphNode.formatId(id)))) .forEach(edges.elements::add); // // Process nodes // sgWorkflow.nodes.elements.stream().map(n -\u0026gt; { if (n instanceof CommandNode commandNode) { Map\u0026lt;String, String\u0026gt; mappings = commandNode.getMappings(); HashMap\u0026lt;String, String\u0026gt; newMappings = new HashMap\u0026lt;\u0026gt;(); mappings.forEach((key, value) -\u0026gt; { newMappings.put(key, subgraphNode.formatId(value)); }); return new CommandNode(subgraphNode.formatId(n.id()), AsyncCommandAction.node_async((state, config1) -\u0026gt; { Command command = commandNode.getAction().apply(state, config1).join(); String NewGoToNode = subgraphNode.formatId(command.gotoNode()); return new Command(NewGoToNode, command.update()); }), newMappings); } return n.withIdUpdated(subgraphNode::formatId); }).forEach(nodes.elements::add); } return new ProcessedNodesEdgesAndConfig(nodes, edges, interruptsBefore, interruptsAfter); } 8.5 ä¸­æ–­å¤„ç† 8.5.1 ä¸­æ–­ CompiledConfigä¸­å®šä¹‰äº†ä¸­æ–­ç‚¹ã€‚graphè¿è¡Œæ—¶ä¼šè‡ªåŠ¨ç”Ÿæˆæ¯ä¸ªèŠ‚ç‚¹çš„Checkpointå¹¶å­˜åˆ°Saveré‡Œé¢ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 private boolean shouldInterruptBefore(String nodeId, String previousNodeId) { if (previousNodeId == null) { // FIX RESUME ERROR return false; } return compileConfig.interruptsBefore().contains(nodeId); } private boolean shouldInterruptAfter(String nodeId, String previousNodeId) { if (nodeId == null) { // FIX RESUME ERROR return false; } return compileConfig.interruptsAfter().contains(nodeId); } private Optional\u0026lt;Checkpoint\u0026gt; addCheckpoint(RunnableConfig config, String nodeId, Map\u0026lt;String, Object\u0026gt; state, String nextNodeId) throws Exception { if (compileConfig.checkpointSaver().isPresent()) { var cp = Checkpoint.builder().nodeId(nodeId).state(cloneState(state)).nextNodeId(nextNodeId).build(); compileConfig.checkpointSaver().get().put(config, cp); return Optional.of(cp); } return Optional.empty(); } è¿è¡Œæ—¶ï¼Œåˆ°è¾¾ä¸­æ–­ç‚¹åï¼Œç›´æ¥return Data.done()\n1 2 3 4 5 6 7 8 9 10 11 12 // check on previous node if (shouldInterruptAfter(currentNodeId, nextNodeId)) { return Data.done(currentNodeId); } if (shouldInterruptBefore(nextNodeId, currentNodeId)) { return Data.done(currentNodeId); } currentNodeId = nextNodeId; var action = nodes.get(currentNodeId); 8.5.2 æ¢å¤ AsyncNodeGeneratoræ„é€ å‡½æ•°ä¸­ï¼Œä¼šæ£€æŸ¥æ˜¯å¼€å§‹è¿˜æ˜¯æ¢å¤ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 protected AsyncNodeGenerator(OverAllState overAllState, RunnableConfig config) throws GraphRunnerException { if (overAllState.isResume()) { // â† æ£€æŸ¥æ˜¯å¦ä¸ºæ¢å¤è¯·æ±‚ log.trace(\u0026#34;RESUME REQUEST\u0026#34;); // 1. è·å–CheckpointSaverå®ä¾‹ BaseCheckpointSaver saver = compileConfig.checkpointSaver() .orElseThrow(() -\u0026gt; (new IllegalStateException( \u0026#34;inputs cannot be null (ie. resume request) if no checkpoint saver is configured\u0026#34;))); // 2. ä»CheckpointSaverè¯»å–æ£€æŸ¥ç‚¹æ•°æ® â† æ ¸å¿ƒè¯»å–ä½ç½®ï¼ Checkpoint startCheckpoint = saver.get(config) .orElseThrow(() -\u0026gt; (new IllegalStateException(\u0026#34;Resume request without a saved checkpoint!\u0026#34;))); // 3. æ¢å¤çŠ¶æ€æ•°æ® this.currentState = startCheckpoint.getState(); // â† çŠ¶æ€æ¢å¤ this.config = config.withCheckPointId(null); this.overAllState = overAllState.input(this.currentState); this.nextNodeId = startCheckpoint.getNextNodeId(); // â† æ¢å¤ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ this.currentNodeId = null; log.trace(\u0026#34;RESUME FROM {}\u0026#34;, startCheckpoint.getNodeId()); } } 9 åºåˆ—åŒ– 9.1 ä½¿ç”¨åœºæ™¯ 9.1.1 Checkpointä¿å­˜ï¼ˆæŒä¹…åŒ–çŠ¶æ€ï¼‰ 1 2 3 4 5 6 7 8 9 10 private Optional\u0026lt;Checkpoint\u0026gt; addCheckpoint(RunnableConfig config, String nodeId, Map\u0026lt;String, Object\u0026gt; state, String nextNodeId) throws Exception { if (compileConfig.checkpointSaver().isPresent()) { var cp = Checkpoint.builder().nodeId(nodeId).state(cloneState(state)).nextNodeId(nextNodeId).build(); compileConfig.checkpointSaver().get().put(config, cp); return Optional.of(cp); } return Optional.empty(); } 9.1.2 Resumeååºåˆ—åŒ– 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 protected AsyncNodeGenerator(OverAllState overAllState, RunnableConfig config) throws GraphRunnerException { if (overAllState.isResume()) { log.trace(\u0026#34;RESUME REQUEST\u0026#34;); BaseCheckpointSaver saver = compileConfig.checkpointSaver() .orElseThrow(() -\u0026gt; (new IllegalStateException( \u0026#34;inputs cannot be null (ie. resume request) if no checkpoint saver is configured\u0026#34;))); Checkpoint startCheckpoint = saver.get(config) .orElseThrow(() -\u0026gt; (new IllegalStateException(\u0026#34;Resume request without a saved checkpoint!\u0026#34;))); this.currentState = startCheckpoint.getState(); // Reset checkpoint id this.config = config.withCheckPointId(null); this.overAllState = overAllState.input(this.currentState); this.nextNodeId = startCheckpoint.getNextNodeId(); this.currentNodeId = null; log.trace(\u0026#34;RESUME FROM {}\u0026#34;, startCheckpoint.getNodeId()); } 9.1.3 çŠ¶æ€æ·±æ‹·è´ 1 2 3 OverAllState cloneState(Map\u0026lt;String, Object\u0026gt; data) throws IOException, ClassNotFoundException { return stateGraph.getStateSerializer().cloneObject(data); } ","date":"2025-06-06T00:00:00Z","permalink":"https://sixiyida.github.io/p/spring-ai-alibaba-graph-core-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/","title":"spring-ai-alibaba-graph-core æºç é˜…è¯»"},{"content":"1. Deep Research ExecutorèŠ‚ç‚¹å¹¶è¡Œ 1.1 é—®é¢˜æè¿° â€‹\tå½“å‰æ¶æ„ä¸­ï¼ŒResearch TeamèŠ‚ç‚¹åçš„è´Ÿè´£æ‰§è¡Œplançš„Executors (Researcher/Coder) æ˜¯ä¸²è¡Œæ‰§è¡Œçš„ï¼Œæ¯ä¸€æ­¥éƒ½éœ€è¦ç­‰å¾…ä¸Šä¸€ä¸ªstepæ‰§è¡Œå®Œæ¯•ï¼Œè€—è´¹å¤§é‡æ—¶é—´ã€‚ç»æµ‹è¯•ï¼Œä¸€ä¸ª5stepçš„planè€—æ—¶éœ€è¦4åˆ†é’Ÿï¼Œå æ®äº†æ•´ä¸ªæ‰§è¡Œæµç¨‹çš„70%ã€‚\nâ€‹\tæµ‹è¯•è§‚å¯Ÿå‘ç°ï¼ŒResearcherNodeçš„stepåŸºæœ¬æ²¡æœ‰ä¸Šä¸‹æ–‡ä¾èµ–ï¼Œæ¯ä¸ªstepç›¸å¯¹ç‹¬ç«‹ï¼Œæ‰€ä»¥å¯ä»¥å¼‚æ­¥å¹¶è¡Œæ‰§è¡Œï¼Œå¢åŠ é€Ÿåº¦ã€‚CoderNodeåœ¨è·å–äº†ResearcherNodeçš„ä¸Šä¸‹æ–‡åï¼Œä¹Ÿå¯ä»¥å¼‚æ­¥å¹¶è¡Œæ‰§è¡Œã€‚\n1.2 ä¿®æ”¹ç­–ç•¥ â€‹\tå¹¶è¡Œå®ç°æœ‰ä¸¤ç§æ–¹æ¡ˆï¼š\nâ€‹\tï¼ˆ1ï¼‰ç›´æ¥åœ¨ResearcherTeamä¸­ï¼Œå¼‚æ­¥åŠ¨æ€åˆ›å»ºnodeactionå¹¶æ‰§è¡Œï¼Œå³æœ‰å¤šå°‘ä¸ªStepå°±åˆ›å»ºå¤šå°‘ä¸ªExecutorNodeï¼Œä¸€æ¬¡å³å¯å®Œæˆæ•´ä¸ªstepï¼Œå¹¶åœ¨ResearcherNodeè¿ä¸€æ¡è‡ªæ—‹è¾¹ï¼Œé˜»å¡çº¿ç¨‹ä»¥ç­‰å¾…ã€‚\nâ€‹\tï¼ˆ2ï¼‰åˆ©ç”¨Graphåº“æä¾›çš„å¹¶è¡ŒèŠ‚ç‚¹ï¼Œå³åˆ›å»ºä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¼‚æ­¥æ‰§è¡Œnodeactionï¼Œè¿™æ ·åˆ©ç”¨äº†å·²æœ‰çš„èƒ½åŠ›ï¼Œç»´æŠ¤æ€§è¾ƒå¥½ã€‚\n1.3 å…·ä½“å®ç° â€‹\tä¸¤ç§æ–¹æ¡ˆéƒ½éœ€è¦ä¾èµ–åœ¨stepä¸­è¿›è¡ŒçŠ¶æ€æ§åˆ¶ï¼Œå³ä¸‰ç§çŠ¶æ€ï¼šassignedã€processingã€completedã€‚å¹¶ä¸”é™„ä¸Šç»™èŠ‚ç‚¹åˆ†é…çš„idã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Data public static class Step { @JsonProperty(\u0026#34;need_web_search\u0026#34;) private boolean needWebSearch; private String title; private String description; @JsonProperty(\u0026#34;step_type\u0026#34;) private StepType stepType; private String executionRes; private String executionStatus; } 1.3.1 æ–¹æ¡ˆ1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 step.setExecutionStatus(assignedStatus); CompletableFuture.runAsync(() -\u0026gt; { try { if (step.getStepType() == Plan.StepType.RESEARCH) { logger.info(\u0026#34;Executing research step {}: {}\u0026#34;, stepIndex, step.getTitle()); // ä¸ºæ¯ä¸ªç ”ç©¶æ­¥éª¤åˆ›å»ºæ–°çš„Agent ChatClient researchAgent = applicationContext.getBean(\u0026#34;researchAgent\u0026#34;, ChatClient.class); ResearcherNode researcherNode = new ResearcherNode(researchAgent, executorNodeId); researcherNode.apply(state); } else { logger.info(\u0026#34;Executing processing step {}: {}\u0026#34;, stepIndex, step.getTitle()); // ä¸ºæ¯ä¸ªå¤„ç†æ­¥éª¤åˆ›å»ºæ–°çš„Agent ChatClient coderAgent = applicationContext.getBean(\u0026#34;coderAgent\u0026#34;, ChatClient.class); CoderNode coderNode = new CoderNode(coderAgent, executorNodeId); coderNode.apply(state); } } catch (Exception e) { logger.error(\u0026#34;Error executing step {}: {}\u0026#34;, stepIndex, step.getTitle(), e); } }, executorService); ä»¥ä¸Šä¸ºæ ¸å¿ƒä»£ç ï¼Œæ¯”è¾ƒç®€å•ç²—æš´ã€‚å³ResearcherTeamNodeç›´æ¥åˆ›å»ºæ–°èŠ‚ç‚¹ï¼Œå¹¶ä¸”ç­‰å¾…ã€‚\n1.3.2 æ–¹æ¡ˆ2 æ–¹æ¡ˆ2æ˜¯æœ€ç»ˆé‡‡çº³çš„æ–¹æ¡ˆã€‚é˜…è¯»Graphå‘ç°å½“å‰graphå®ç°æœ‰ä»¥ä¸‹é™åˆ¶ï¼š\nï¼ˆ1ï¼‰å­å›¾èŠ‚ç‚¹ä¸èƒ½åŒ…å«æœ‰å¹¶è¡ŒèŠ‚ç‚¹\nï¼ˆ2ï¼‰å¹¶è¡ŒèŠ‚ç‚¹å¿…é¡»æ˜¯æ€»åˆ†æ€»çš„ç»“æ„ï¼Œå¹¶ä¸”ä¼šåœ¨æ±‡æ€»èŠ‚ç‚¹ç­‰å¾…æ‰€æœ‰å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œå®Œæ¯•ã€‚\nï¼ˆ3ï¼‰å¹¶è¡ŒèŠ‚ç‚¹æ€»åˆ†æ€»ç»“æ„ä¸­æ‰€æœ‰è¾¹ä¸èƒ½æ˜¯conditionalã€‚\nï¼ˆ4ï¼‰ä¸æ”¯æŒå¹¶è¡Œæµå¼å¤„ç†ã€‚\nä¸ºç»•å¼€/è§£å†³é™åˆ¶ï¼Œé‡‡å–ä»¥ä¸‹æ–¹æ¡ˆï¼š\nå¯¹äºï¼ˆ1ï¼‰ï¼Œç›´æ¥ä¸ä½¿ç”¨å­å›¾èŠ‚ç‚¹ï¼Œåœ¨å¤§å›¾ä¸­è¿›è¡Œç»“æ„ä¿®æ”¹ã€‚\nå¯¹äºï¼ˆ3ï¼‰ï¼Œç”±äºå½“å‰researcherTeamNodeéœ€è¦åˆ°reporterNodeæˆ–è€…executorNodeï¼Œæ•…å¹¶è¡ŒèŠ‚ç‚¹ä¸èƒ½æ˜¯researcherTeamNodeï¼Œéœ€è¦å•ç‹¬åˆ›å»ºä¸€ä¸ªParallelExecutorNodeæ¥ç»™ExecutorNodeåˆ†é…ä»»åŠ¡ã€‚\nå¯¹äºï¼ˆ2ï¼‰ï¼Œé‡‡å–researcherTeamNode -\u0026gt; ParallelExecutorNode -\u0026gt; ExecutorNodes -\u0026gt; researcherTeamNodeçš„ç¯å½¢ç»“æ„ï¼Œåœ¨ç¬¬äºŒæ¬¡è¿›å…¥researcherTeamNodeçš„æ—¶å€™ç­‰å¾…ã€‚\nå¯¹äºï¼ˆ4ï¼‰ï¼Œåˆ†æå¹¶ä¿®æ”¹Graph Coreä»£ç ã€‚\n1.3.2.1 ParallelExecutorNode ä¸»è¦ä»»åŠ¡ï¼šåˆ†é…stepç»™åç»­èŠ‚ç‚¹ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 /* * Copyright 2025 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.alibaba.cloud.ai.example.deepresearch.node; import com.alibaba.cloud.ai.example.deepresearch.model.ParallelEnum; import com.alibaba.cloud.ai.example.deepresearch.model.dto.Plan; import com.alibaba.cloud.ai.example.deepresearch.util.StateUtil; import com.alibaba.cloud.ai.example.deepresearch.config.DeepResearchProperties; import com.alibaba.cloud.ai.graph.OverAllState; import com.alibaba.cloud.ai.graph.action.NodeAction; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.util.CollectionUtils; import org.springframework.util.StringUtils; import java.util.Map; /** * @author sixiyida * @since 2025/6/12 */ public class ParallelExecutorNode implements NodeAction { private static final Logger logger = LoggerFactory.getLogger(ParallelExecutorNode.class); private final Map\u0026lt;String, Integer\u0026gt; parallelNodeCount; public ParallelExecutorNode(DeepResearchProperties properties) { this.parallelNodeCount = properties.getParallelNodeCount(); } @Override public Map\u0026lt;String, Object\u0026gt; apply(OverAllState state) throws Exception { long currResearcher = 0; long currCoder = 0; Plan curPlan = StateUtil.getPlan(state); for (Plan.Step step : curPlan.getSteps()) { // è·³è¿‡ä¸éœ€è¦å¤„ç†çš„æ­¥éª¤ if (StringUtils.hasText(step.getExecutionRes()) || StringUtils.hasText(step.getExecutionStatus())) { continue; } Plan.StepType stepType = step.getStepType(); switch (stepType) { case PROCESSING: if (areAllResearchStepsCompleted(curPlan)) { step.setExecutionStatus(assignRole(stepType, currCoder)); currCoder = (currCoder + 1) % parallelNodeCount.get(ParallelEnum.RESEARCHER.getValue()); } logger.info(\u0026#34;Waiting for remaining research steps executed\u0026#34;); break; case RESEARCH: step.setExecutionStatus(assignRole(stepType, currResearcher)); currResearcher = (currResearcher + 1) % parallelNodeCount.get(ParallelEnum.CODER.getValue()); break; // å¤„ç†å…¶ä»–å¯èƒ½çš„StepType default: logger.debug(\u0026#34;Unhandled step type: {}\u0026#34;, stepType); } } return Map.of(); } private String assignRole(Plan.StepType type, long executorId) { String role = type == Plan.StepType.PROCESSING ? ParallelEnum.CODER.getValue() : ParallelEnum.RESEARCHER.getValue(); return StateUtil.EXECUTION_STATUS_ASSIGNED_PREFIX + role + \u0026#34;_\u0026#34; + executorId; } private boolean areAllResearchStepsCompleted(Plan plan) { if (CollectionUtils.isEmpty(plan.getSteps())) { return true; } return plan.getSteps() .stream() .filter(step -\u0026gt; step.getStepType() == Plan.StepType.RESEARCH) .allMatch(step -\u0026gt; step.getExecutionStatus().startsWith(StateUtil.EXECUTION_STATUS_COMPLETED_PREFIX)); } } 1.3.2.2 ResearcherNode ä¸»è¦ä»»åŠ¡ï¼šæ‰§è¡Œstepï¼Œæµå¼è¿”å›ï¼Œæ›´æ–°çŠ¶æ€ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 /* * Copyright 2025 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.alibaba.cloud.ai.example.deepresearch.node; import com.alibaba.cloud.ai.example.deepresearch.model.dto.Plan; import com.alibaba.cloud.ai.example.deepresearch.util.StateUtil; import com.alibaba.cloud.ai.graph.OverAllState; import com.alibaba.cloud.ai.graph.action.NodeAction; import com.alibaba.cloud.ai.graph.streaming.StreamingChatGenerator; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.ai.chat.client.ChatClient; import org.springframework.ai.chat.messages.Message; import org.springframework.ai.chat.messages.UserMessage; import org.springframework.util.StringUtils; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Objects; /** * @author sixiyida * @since 2025/6/14 11:17 */ public class ResearcherNode implements NodeAction { private static final Logger logger = LoggerFactory.getLogger(ResearcherNode.class); private final ChatClient researchAgent; private final String executorNodeId; private final String nodeName; public ResearcherNode(ChatClient researchAgent) { this(researchAgent, \u0026#34;0\u0026#34;); } public ResearcherNode(ChatClient researchAgent, String executorNodeId) { this.researchAgent = researchAgent; this.executorNodeId = executorNodeId; this.nodeName = \u0026#34;researcher_\u0026#34; + executorNodeId; } @Override public Map\u0026lt;String, Object\u0026gt; apply(OverAllState state) throws Exception { logger.info(\u0026#34;researcher node {} is running.\u0026#34;, executorNodeId); Plan currentPlan = StateUtil.getPlan(state); List\u0026lt;String\u0026gt; observations = StateUtil.getMessagesByType(state, \u0026#34;observations\u0026#34;); Map\u0026lt;String, Object\u0026gt; updated = new HashMap\u0026lt;\u0026gt;(); Plan.Step assignedStep = null; for (Plan.Step step : currentPlan.getSteps()) { if (Plan.StepType.RESEARCH.equals(step.getStepType()) \u0026amp;\u0026amp; !StringUtils.hasText(step.getExecutionRes()) \u0026amp;\u0026amp; StringUtils.hasText(step.getExecutionStatus()) \u0026amp;\u0026amp; step.getExecutionStatus().equals(StateUtil.EXECUTION_STATUS_ASSIGNED_PREFIX + nodeName)) { assignedStep = step; break; } } // å¦‚æœæ²¡æœ‰æ‰¾åˆ°åˆ†é…çš„æ­¥éª¤ï¼Œç›´æ¥è¿”å› if (assignedStep == null) { logger.info(\u0026#34;No remaining steps to be executed by {}\u0026#34;, nodeName); return updated; } // æ ‡è®°æ­¥éª¤ä¸ºæ­£åœ¨æ‰§è¡Œ assignedStep.setExecutionStatus(StateUtil.EXECUTION_STATUS_PROCESSING_PREFIX + nodeName); // æ·»åŠ ä»»åŠ¡æ¶ˆæ¯ List\u0026lt;Message\u0026gt; messages = new ArrayList\u0026lt;\u0026gt;(); Message taskMessage = new UserMessage(String.format(\u0026#34;# Current Task\\n\\n##title\\n\\n%s\\n\\n##description\\n\\n%s\u0026#34;, assignedStep.getTitle(), assignedStep.getDescription())); messages.add(taskMessage); // æ·»åŠ ç ”ç©¶è€…ç‰¹æœ‰çš„å¼•ç”¨æé†’ Message citationMessage = new UserMessage( \u0026#34;IMPORTANT: DO NOT include inline citations in the text. Instead, track all sources and include a References section at the end using link reference format. Include an empty line between each citation for better readability. Use this format for each reference:\\n- [Source Title](URL)\\n\\n- [Another Source](URL)\u0026#34;); messages.add(citationMessage); logger.debug(\u0026#34;researcher Node messages: {}\u0026#34;, messages); // è°ƒç”¨agent var streamResult = researchAgent.prompt().messages(messages).stream().chatResponse(); Plan.Step finalAssignedStep = assignedStep; logger.info(\u0026#34;ResearcherNode {} starting streaming with key: {}\u0026#34;, executorNodeId, \u0026#34;researcher_llm_stream_\u0026#34; + executorNodeId); var generator = StreamingChatGenerator.builder() .startingNode(\u0026#34;researcher_llm_stream_\u0026#34; + executorNodeId) .startingState(state) .mapResult(response -\u0026gt; { finalAssignedStep.setExecutionStatus(StateUtil.EXECUTION_STATUS_COMPLETED_PREFIX + executorNodeId); String researchContent = response.getResult().getOutput().getText(); finalAssignedStep.setExecutionRes(Objects.requireNonNull(researchContent)); logger.info(\u0026#34;{} completed, content: {}\u0026#34;, nodeName, researchContent); observations.add(researchContent); updated.put(\u0026#34;observations\u0026#34;, observations); updated.put(\u0026#34;researcher_content_\u0026#34; + executorNodeId, List.of(researchContent)); return updated; }) .build(streamResult); updated.put(\u0026#34;researcher_content_\u0026#34; + executorNodeId, generator); return updated; } } 1.3.2.3 CoderNode åŒä¸Šï¼Œè·³è¿‡ã€‚\n1.4 Graph Coreä¿®æ”¹ ä¸»è¦é—®é¢˜ï¼šä¸æ”¯æŒå¹¶è¡Œæµå¼å¤„ç†ã€‚\n1.4.1 è°ƒç”¨é“¾è·¯åˆ†æ æˆ‘ä»¬æ¥çœ‹çœ‹ç›®å‰çš„æµå¼è¿”å›æ˜¯å¦‚ä½•å®ç°çš„ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var generator = StreamingChatGenerator.builder() .startingNode(\u0026#34;researcher_llm_stream_\u0026#34; + executorNodeId) .startingState(state) .mapResult(response -\u0026gt; { finalAssignedStep.setExecutionStatus(StateUtil.EXECUTION_STATUS_COMPLETED_PREFIX + executorNodeId); String researchContent = response.getResult().getOutput().getText(); finalAssignedStep.setExecutionRes(Objects.requireNonNull(researchContent)); logger.info(\u0026#34;{} completed, content: {}\u0026#34;, nodeName, researchContent); observations.add(researchContent); updated.put(\u0026#34;observations\u0026#34;, observations); updated.put(\u0026#34;researcher_content_\u0026#34; + executorNodeId, List.of(researchContent)); return updated; }) .build(streamResult); updated.put(\u0026#34;researcher_content_\u0026#34; + executorNodeId, generator); ä»¥ä¸Šä»£ç æ¥è‡ªresearcherNodeï¼Œè¿”å›ä¸€ä¸ªMapåï¼Œæˆ‘ä»¬æ¥çœ‹æ˜¯åœ¨å“ªé‡Œæ‰§è¡Œçš„ã€‚\n1.4.1.1 å…¥å£æ¥å£ 1 2 3 4 5 6 7 8 9 10 11 @RequestMapping(value = \u0026#34;/chat/stream\u0026#34;, method = RequestMethod.POST, produces = MediaType.TEXT_EVENT_STREAM_VALUE) public Flux\u0026lt;ServerSentEvent\u0026lt;String\u0026gt;\u0026gt; chatStream(@RequestBody(required = false) ChatRequest chatRequest) throws GraphRunnerException { //... else { ChatRequestProcess.initializeObjectMap(chatRequest, objectMap); logger.info(\u0026#34;init inputs: {}\u0026#34;, objectMap); AsyncGenerator\u0026lt;NodeOutput\u0026gt; resultFuture = compiledGraph.stream(objectMap, runnableConfig); graphProcess.processStream(resultFuture, sink); } } è¿™æ˜¯ä¸€ä¸ªControlleræ¥å£ï¼Œå¯ä»¥çœ‹åˆ°ï¼Œå›¾æ˜¯ä»è¿™ä¸ªæ–¹æ³•è¿›å»çš„compiledGraph.stream(objectMap, runnableConfig);ã€‚\næˆ‘ä»¬æ¥çœ‹çœ‹å…·ä½“å®ç°ï¼š\n1 2 3 4 5 public AsyncGenerator\u0026lt;NodeOutput\u0026gt; stream(Map\u0026lt;String, Object\u0026gt; inputs, RunnableConfig config) throws GraphRunnerException { Objects.requireNonNull(config, \u0026#34;config cannot be null\u0026#34;); final AsyncNodeGenerator\u0026lt;NodeOutput\u0026gt; generator = new AsyncNodeGenerator\u0026lt;\u0026gt;(stateCreate(inputs), config); return new AsyncGenerator.WithEmbed\u0026lt;\u0026gt;(generator); } è¿™ä¸ªåœ°æ–¹è¿”å›äº†ä¸€ä¸ªAsyncGenerator.WithEmbedï¼Œè¿™ç©æ„æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ\nç®€è€Œè¨€ä¹‹ï¼Œè¿™ä¸ªä¸œè¥¿æ˜¯ä¸€ä¸ªå…è®¸å…¶ä»–çš„AsyncGeneratoråœ¨å…¶æ‰§è¡Œè¿‡ç¨‹ä¸­æ‰§è¡Œçš„åŒ…è£…ç±»ã€‚\næ‰§è¡Œæµç¨‹æ˜¯ï¼š\nä»å †æ ˆé¡¶éƒ¨è·å–å½“å‰ç”Ÿæˆå™¨\nè°ƒç”¨å½“å‰ç”Ÿæˆå™¨çš„next()æ–¹æ³•è·å–ç»“æœ\nå¦‚æœç»“æœè¡¨ç¤ºç”Ÿæˆå™¨å·²å®Œæˆï¼š\næ¸…é™¤ä¹‹å‰çš„è¿”å›å€¼ï¼ˆå¦‚æœæœ‰ï¼‰\nå°†ç»“æœæ¨å…¥è¿”å›å€¼å †æ ˆ\næ‰§è¡Œå®Œæˆå›è°ƒï¼ˆå¦‚æœæœ‰ï¼‰\nå¦‚æœè¿™æ˜¯æœ€åä¸€ä¸ªç”Ÿæˆå™¨ï¼Œè¿”å›ç»“æœ\nå¦åˆ™ï¼Œå¼¹å‡ºå½“å‰ç”Ÿæˆå™¨ï¼Œé€’å½’è°ƒç”¨next()ç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ªç”Ÿæˆå™¨\nå¦‚æœç»“æœåŒ…å«ä¸€ä¸ªåµŒå…¥ç”Ÿæˆå™¨ï¼š æ£€æŸ¥åµŒå¥—æ·±åº¦ï¼ˆç›®å‰ä¸æ”¯æŒé€’å½’åµŒå¥—ï¼‰\nå°†åµŒå…¥ç”Ÿæˆå™¨æ¨å…¥å †æ ˆ\né€’å½’è°ƒç”¨next()å¤„ç†åµŒå…¥ç”Ÿæˆå™¨\nå¦åˆ™ï¼Œç›´æ¥è¿”å›ç»“æœ çœ‹çœ‹å…·ä½“å®ç°ï¼š\n1 2 protected final Deque\u0026lt;Embed\u0026lt;E\u0026gt;\u0026gt; generatorsStack = new ArrayDeque\u0026lt;\u0026gt;(2); private final Deque\u0026lt;Data\u0026lt;E\u0026gt;\u0026gt; returnValueStack = new ArrayDeque\u0026lt;\u0026gt;(2); é¦–å…ˆæ ¸å¿ƒæ•°æ®ç»“æ„æ˜¯åˆ©ç”¨è¿™ä¸¤ä¸ªåŒç«¯é˜Ÿåˆ—ç»´æŠ¤è¿”å›å€¼å’Œç”Ÿæˆå™¨æ ˆã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @Override public Data\u0026lt;E\u0026gt; next() { if (generatorsStack.isEmpty()) { // GUARD throw new IllegalStateException(\u0026#34;no generator found!\u0026#34;); } final Embed\u0026lt;E\u0026gt; embed = generatorsStack.peek(); final Data\u0026lt;E\u0026gt; result = embed.generator.next(); if (result.isDone()) { clearPreviousReturnsValuesIfAny(); returnValueStack.push(result); if (embed.onCompletion != null) { try { embed.onCompletion.accept(result.resultValue); } catch (Exception e) { return Data.error(e); } } if (isLastGenerator()) { return result; } generatorsStack.pop(); return next(); } if (result.embed != null) { if (generatorsStack.size() \u0026gt;= 2) { return Data.error(new UnsupportedOperationException( \u0026#34;Currently recursive nested generators are not supported!\u0026#34;)); } generatorsStack.push(result.embed); return next(); } return result; } è¿™ä¸ªæ–¹æ³•æ˜¯æ ¸å¿ƒæ–¹æ³•ï¼Œé€’å½’åœ°å¤„ç†äº†åµŒå…¥çš„ç”Ÿæˆå™¨ã€‚\n1.4.1.2 çŠ¶æ€æµè½¬ ç„¶åæˆ‘ä»¬æ¥çœ‹çœ‹AsyncNodeGeneratorçš„å®ç°ï¼š\næ ¸å¿ƒæ–¹æ³•æ˜¯nextï¼Œå…¶å®ç°äº†çŠ¶æ€å›¾æµè½¬ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @Override public Data\u0026lt;o\u0026gt; next() { try { // æ£€æŸ¥æœ€å¤§è¿­ä»£æ¬¡æ•° if (++iteration \u0026gt; maxIterations) { return Data.error(new IllegalStateException( format(\u0026#34;Maximum number of iterations (%d) reached!\u0026#34;, maxIterations))); } // æ£€æŸ¥æ˜¯å¦å·²ç»“æŸ if (nextNodeId == null \u0026amp;\u0026amp; currentNodeId == null) { return releaseThread().map(Data::\u0026lt;o\u0026gt;done).orElseGet(() -\u0026gt; Data.done(currentState)); } // æ˜¯å¦ä»åµŒå…¥æ¢å¤ if (resumedFromEmbed) { final CompletableFuture\u0026lt;o\u0026gt; future = getNodeOutput(); resumedFromEmbed = false; return Data.of(future); } // å¤„ç†STARTèŠ‚ç‚¹ if (START.equals(currentNodeId)) { doListeners(START, null); var nextNodeCommand = getEntryPoint(currentState, config); nextNodeId = nextNodeCommand.gotoNode(); currentState = nextNodeCommand.update(); var cp = addCheckpoint(config, START, currentState, nextNodeId); var output = (cp.isPresent() \u0026amp;\u0026amp; config.streamMode() == StreamMode.SNAPSHOTS) ? buildStateSnapshot(cp.get()) : buildNodeOutput(currentNodeId); currentNodeId = nextNodeId; return Data.of(output); } // å¤„ç†ENDèŠ‚ç‚¹ if (END.equals(nextNodeId)) { nextNodeId = null; currentNodeId = null; doListeners(END, null); return Data.of(buildNodeOutput(END)); } // æ£€æŸ¥ä¸­æ–­æ¡ä»¶ if (shouldInterruptAfter(currentNodeId, nextNodeId)) { return Data.done(currentNodeId); } if (shouldInterruptBefore(nextNodeId, currentNodeId)) { return Data.done(currentNodeId); } // æ›´æ–°å½“å‰èŠ‚ç‚¹ID currentNodeId = nextNodeId; // è·å–å½“å‰èŠ‚ç‚¹å¯¹åº”çš„åŠ¨ä½œ var action = nodes.get(currentNodeId); if (action == null) throw RunnableErrors.missingNode.exception(currentNodeId); // æ‰§è¡ŒèŠ‚ç‚¹åŠ¨ä½œ return evaluateAction(action, this.overAllState).get(); } catch (Exception e) { doListeners(ERROR, e); log.error(e.getMessage(), e); return Data.error(e); } } å…¶ä¸­evaluateActionæ‰§è¡Œäº†nodeActionï¼Œä»£ç å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 private Command nextNodeId(String nodeId, OverAllState overAllState, Map\u0026lt;String, Object\u0026gt; state, RunnableConfig config) throws Exception { EdgeValue route = edges.get(nodeId); if (route == null) { throw RunnableErrors.missingEdge.exception(nodeId); } // å¦‚æœè¾¹æœ‰å›ºå®šçš„ç›®æ ‡ID if (route.id() != null) { return new Command(route.id(), state); } // å¦‚æœè¾¹æœ‰æ¡ä»¶é€»è¾‘ if (route.value() != null) { // æ‰§è¡Œè¾¹çš„æ¡ä»¶åŠ¨ä½œ var command = route.value().action().apply(overAllState, config).get(); var newRoute = command.gotoNode(); // æ ¹æ®æ¡ä»¶ç»“æœæŸ¥æ‰¾æ˜ å°„çš„ç›®æ ‡èŠ‚ç‚¹ String result = route.value().mappings().get(newRoute); if (result == null) { throw RunnableErrors.missingNodeInEdgeMapping.exception(nodeId, newRoute); } // æ›´æ–°çŠ¶æ€ var currentState = OverAllState.updateState(state, command.update(), keyStrategyMap); overAllState.updateState(command.update()); return new Command(result, currentState); } throw RunnableErrors.executionError.exception(format(\u0026#34;invalid edge value for nodeId: [%s] !\u0026#34;, nodeId)); } ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ç”±nextNodeIdæ–¹æ³•å†³å®šï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 private Command nextNodeId(String nodeId, OverAllState overAllState, Map\u0026lt;String, Object\u0026gt; state, RunnableConfig config) throws Exception { EdgeValue route = edges.get(nodeId); if (route == null) { throw RunnableErrors.missingEdge.exception(nodeId); } // å¦‚æœè¾¹æœ‰å›ºå®šçš„ç›®æ ‡ID if (route.id() != null) { return new Command(route.id(), state); } // å¦‚æœè¾¹æœ‰æ¡ä»¶é€»è¾‘ if (route.value() != null) { // æ‰§è¡Œè¾¹çš„æ¡ä»¶åŠ¨ä½œ var command = route.value().action().apply(overAllState, config).get(); var newRoute = command.gotoNode(); // æ ¹æ®æ¡ä»¶ç»“æœæŸ¥æ‰¾æ˜ å°„çš„ç›®æ ‡èŠ‚ç‚¹ String result = route.value().mappings().get(newRoute); if (result == null) { throw RunnableErrors.missingNodeInEdgeMapping.exception(nodeId, newRoute); } // æ›´æ–°çŠ¶æ€ var currentState = OverAllState.updateState(state, command.update(), keyStrategyMap); overAllState.updateState(command.update()); return new Command(result, currentState); } throw RunnableErrors.executionError.exception(format(\u0026#34;invalid edge value for nodeId: [%s] !\u0026#34;, nodeId)); } ","date":"2025-06-06T00:00:00Z","permalink":"https://sixiyida.github.io/p/spring-ai-alibaba%E7%BB%B4%E6%8A%A4%E8%AE%B0%E5%BD%95/","title":"spring-ai-alibabaç»´æŠ¤è®°å½•"},{"content":"åˆ†åº“åˆ†è¡¨å’Œåˆ†é¡µ 1. åˆ†è¡¨ï¼ˆTable Shardingï¼‰ å®šä¹‰ï¼šå°†å•å¼ æ•°æ®è¡¨æŒ‰ç‰¹å®šè§„åˆ™ï¼ˆå¦‚å“ˆå¸Œã€èŒƒå›´ï¼‰æ‹†åˆ†ä¸ºå¤šä¸ªç»“æ„ç›¸åŒçš„å°è¡¨ï¼Œå­˜å‚¨åœ¨åŒä¸€æ•°æ®åº“æˆ–ä¸åŒæ•°æ®åº“ä¸­\nç›®çš„ï¼šè§£å†³å•è¡¨æ•°æ®é‡è¿‡å¤§å¯¼è‡´çš„æŸ¥è¯¢æ€§èƒ½ä¸‹é™ï¼ˆå¦‚ç´¢å¼•è†¨èƒ€ã€ç£ç›˜I/Oç“¶é¢ˆï¼‰\né€‚ç”¨åœºæ™¯ï¼šå•è¡¨æ•°æ®è¶…åƒä¸‡çº§ï¼Œä½†æ•°æ®åº“å®ä¾‹èµ„æºæœªè¾¾ç“¶é¢ˆ\n2. åˆ†åº“ï¼ˆDatabase Shardingï¼‰ å®šä¹‰ï¼šå°†æ•´ä¸ªæ•°æ®åº“æŒ‰ä¸šåŠ¡æˆ–æ•°æ®ç»´åº¦æ‹†åˆ†ä¸ºå¤šä¸ªç‹¬ç«‹çš„æ•°æ®åº“å®ä¾‹ï¼Œæ¯ä¸ªå®ä¾‹å­˜å‚¨éƒ¨åˆ†æ•°æ®\nç›®çš„ï¼šè§£å†³å•åº“è¿æ¥æ•°ä¸è¶³ã€ç£ç›˜ç©ºé—´ä¸è¶³ã€å†™å¹¶å‘å‹åŠ›å¤§ç­‰é—®é¢˜\né€‚ç”¨åœºæ™¯ï¼šå•åº“QPSè¿‡é«˜ã€è¿æ¥æ•°è€—å°½æˆ–éœ€æ•…éšœéš”ç¦»\n3. åˆ†ç‰‡ï¼ˆShardingï¼‰ å®šä¹‰ï¼šåˆ†åº“+åˆ†è¡¨çš„ç»„åˆç­–ç•¥ï¼Œå°†æ•°æ®æŒ‰è§„åˆ™ï¼ˆå¦‚å“ˆå¸Œã€èŒƒå›´ï¼‰åˆ†å¸ƒåˆ°å¤šä¸ªæ•°æ®åº“èŠ‚ç‚¹ï¼ˆåˆ†ç‰‡ï¼‰ï¼Œæ¯ä¸ªèŠ‚ç‚¹åŒ…å«éƒ¨åˆ†åº“å’Œè¡¨ã€‚\nç›®çš„ï¼šå®ç°çœŸæ­£çš„æ°´å¹³æ‰©å±•ï¼Œæ”¯æŒæµ·é‡æ•°æ®ä¸é«˜å¹¶å‘\né€‚ç”¨åœºæ™¯ï¼šè¶…å¤§è§„æ¨¡æ•°æ®ï¼ˆTB/PBçº§ï¼‰ã€éœ€å…¨å±€è´Ÿè½½å‡è¡¡\næ ¸å¿ƒåŒºåˆ«æ€»ç»“ ç»´åº¦ åˆ†è¡¨ åˆ†åº“ åˆ†ç‰‡ æ‹†åˆ†å¯¹è±¡ å•å¼ è¡¨ æ•´ä¸ªæ•°æ®åº“å®ä¾‹ åº“+è¡¨ç»„åˆçš„åˆ†å¸ƒå¼èŠ‚ç‚¹ ä¸»è¦ç›®æ ‡ è§£å†³å•è¡¨æ€§èƒ½ç“¶é¢ˆ è§£å†³å•åº“èµ„æºç“¶é¢ˆ å…¨å±€æ°´å¹³æ‰©å±•ä¸é«˜å¯ç”¨ æ•°æ®åˆ†å¸ƒ è¡¨å†…æ•°æ®æ‹†åˆ† åº“é—´æ•°æ®éš”ç¦» è·¨èŠ‚ç‚¹æ•°æ®åˆ†ç‰‡ å…¸å‹åœºæ™¯ å¤§è¡¨æŸ¥è¯¢ä¼˜åŒ– é«˜å¹¶å‘å†™å…¥/è¿æ¥æ•°ä¸è¶³ è¶…å¤§è§„æ¨¡ç³»ç»Ÿï¼ˆå¦‚ç¤¾äº¤å¹³å°ï¼‰ ","date":"2025-06-02T00:00:00Z","permalink":"https://sixiyida.github.io/p/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","title":"ç³»ç»Ÿè®¾è®¡"},{"content":"0. å‰è¨€ èŠ±äº†5å¤©æ—¶é—´æ˜¯è·Ÿç€åšå®Œäº†é»‘é©¬ç‚¹è¯„é¡¹ç›®ã€‚è™½è¯´æ˜¯çƒ‚å¤§è¡—é¡¹ç›®ä¹‹ä¸€ï¼Œä½†æˆ‘è¿˜æ˜¯å­¦åˆ°äº†ä¸å°‘ä¸œè¥¿ã€‚è¿™ä¸ªé¡¹ç›®è®©æˆ‘ç¬¬ä¸€æ¬¡çœ‹åˆ°äº†åç«¯çš„å…¨è²Œã€‚è¿™ç¯‡æ–‡ç« ä¼šè®°å½•æˆ‘ä¼˜åŒ–è¿™ä¸ªé¡¹ç›®çš„è¿‡ç¨‹ï¼Œæ¶‰åŠä¸­é—´ä»¶ã€åŠŸèƒ½æ‹“å±•ã€LLMçš„å¼•å…¥ç­‰ã€‚\n1. å¼•å…¥æ¶ˆæ¯é˜Ÿåˆ—ä¸­é—´ä»¶ åœ¨é¡¹ç›®çš„ç§’æ€ä¸šåŠ¡ä¸­ï¼Œä¼˜æƒ åˆ¸ä¸‹å•å’Œæ•°æ®æŒä¹…åŒ–è‡³æ•°æ®åº“åˆ©ç”¨Redis Streamå®ç°çš„æ¶ˆæ¯é˜Ÿåˆ—è§£è€¦ï¼Œä¼˜åŠ¿ä¸»è¦åœ¨ï¼š\nç®€åŒ–ä¸‹å•æµç¨‹ï¼Œæé«˜ç³»ç»Ÿå“åº”é€Ÿåº¦ã€‚ æé«˜å¹¶å‘é‡å’Œé²æ£’æ€§ï¼Œé˜²æ­¢æ•°æ®åº“å‡»ç©¿ã€‚ 1.1 ä¸ºä»€ä¹ˆå¼•å…¥æ¶ˆæ¯é˜Ÿåˆ—ä¸­é—´ä»¶ï¼Ÿ æŒä¹…åŒ–ï¼šRedis Streamä¾èµ–AOF/RDBæŒä¹…åŒ–ï¼Œä¸»ä»åˆ‡æ¢æ—¶å¼‚æ­¥å¤åˆ¶å¯èƒ½å¯¼è‡´æ•°æ®ä¸¢å¤±ï¼›æ¶ˆæ¯é˜Ÿåˆ—ä¸­é—´ä»¶ï¼Œå¦‚RocketMQï¼ŒåŒæ­¥åˆ·ç›˜+å¤šå‰¯æœ¬ï¼ˆRAFTåè®®ï¼‰ï¼Œæä¾›é‡‘èçº§å¯é æ€§ã€‚\næ¶ˆæ¯ç§¯å‹ï¼š\nèƒ½åŠ› Redis Stream ä¸“ä¸šæ¶ˆæ¯é˜Ÿåˆ— å­˜å‚¨ä»‹è´¨ å†…å­˜ï¼ˆæˆæœ¬é«˜ï¼‰ ç£ç›˜ï¼ˆæˆæœ¬ä½ï¼‰ ç§¯å‹å®¹å¿åº¦ éœ€è®¾ç½®MAXLENæˆªæ–­æ—§æ¶ˆæ¯ æ”¯æŒTBçº§å †ç§¯ï¼ˆå¦‚Kafkaï¼‰ å†…å­˜é£é™© å¯èƒ½è§¦å‘OOMï¼ˆéœ€æ‰‹åŠ¨æ‰©å†…å­˜ï¼‰ ç£ç›˜ç©ºé—´è‡ªåŠ¨æ‰©å®¹æ— å‹åŠ› è¿ç»´ä¸ç”Ÿæ€ï¼šä¸“ä¸šæ¶ˆæ¯é˜Ÿåˆ—å·¥å…·é“¾æ›´å®Œå–„ã€‚\né«˜çº§åŠŸèƒ½ï¼šæ¶ˆæ¯é˜Ÿåˆ—ä¸­é—´ä»¶å¼•å…¥äº†å»¶è¿Ÿé˜Ÿåˆ—ã€æ­»ä¿¡è·¯ç”±ç­‰ä¼ä¸šçº§ç‰¹æ€§ã€‚\n1.2 å¼•å…¥å“ªä¸€ç§ï¼Ÿ ä¸‰ç§ä¸­é—´ä»¶å¯¹æ¯”ï¼š\nèƒ½åŠ›ç»´åº¦ RabbitMQ Kafka RocketMQ ååé‡ ä¸‡çº§ TPS ç™¾ä¸‡çº§ TPS åä¸‡çº§ TPS å»¶è¿Ÿ å¾®ç§’çº§ æ¯«ç§’çº§ï¼ˆæ‰¹å¤„ç†è®¾è®¡ï¼‰ æ¯«ç§’çº§ äº‹åŠ¡æ”¯æŒ è½»é‡çº§äº‹åŠ¡ï¼ˆåŒæ­¥é˜»å¡ï¼‰ æ”¯æŒï¼ˆâ‰¥0.11 ç‰ˆæœ¬ï¼‰ åˆ†å¸ƒå¼äº‹åŠ¡æ¶ˆæ¯ é¡ºåºæ€§ä¿éšœ å•é˜Ÿåˆ—æœ‰åº åˆ†åŒºå†…æœ‰åº é˜Ÿåˆ—/åˆ†åŒºä¸¥æ ¼æœ‰åº å¯é æ€§æœºåˆ¶ é•œåƒé˜Ÿåˆ—+æŒä¹…åŒ– å¤šå‰¯æœ¬+ISR åŒæ­¥åˆ·ç›˜+å¤šå‰¯æœ¬+RAFT åè®® ç§’æ€æ ¸å¿ƒä¼˜åŠ¿ å‰Šå³°å¡«è°·ã€å¼‚æ­¥è§£è€¦ è¶…é«˜ååã€æ—¥å¿—æµå¤„ç† é«˜å¹¶å‘+å¼ºä¸€è‡´æ€§+ä½å»¶è¿Ÿ ç»“è®ºï¼šé€‰æ‹©RocketMQï¼Œç§’æ€åœºæ™¯åœ¨éœ€è¦é«˜ååé‡çš„åŒæ—¶ï¼Œéœ€è¦å¼ºä¸€è‡´æ€§å’Œå¯é æ€§ã€‚åŒæ—¶RocketMQæ”¯æ’‘é˜¿é‡Œå¤šæ¬¡åŒåä¸€æ´»åŠ¨ï¼Œéå¸¸æ— æ•Œï¼Œå¿…é¡»å–½ä»–ã€‚\n1.3 å¼•å…¥RocketMQ 1.3.1 éƒ¨ç½²RocketMQ ç”±äºæœ¬äººå¤ªç©·ï¼ŒæœåŠ¡å™¨åªæœ‰2æ ¸2Gï¼Œä½†åˆä¸æƒ³å¦¥åç”¨è½»é‡çº§çš„MQï¼Œä¸ºéªŒè¯é¡¹ç›®é€»è¾‘ï¼Œåœ¨æœ¬åœ°Windowsç¯å¢ƒéƒ¨ç½²RocketMQã€‚\nä¸‹è½½è·³è¿‡ã€‚\né…ç½®ç¯å¢ƒå˜é‡ï¼š\n1 2 %ROCKETMQ_HOME% = ...\\rocketmq-all-5.3.3-bin-release %NAMESRV_ADDR% = localhost:9876 å¯åŠ¨NameServerå’ŒBrokerï¼š\n1 2 3 cd %ROCKETMQ_HOME% bin/mqnamesrv bin/mqbroker -n localhost:9876 æµ‹è¯•ç”Ÿäº§æ¶ˆè´¹ï¼š\n1 2 bin/tools org.apache.rocketmq.example.quickstart.Producer bin/tools org.apache.rocketmq.example.quickstart.Consumer 1.3.2 å¼•å…¥Javaå®¢æˆ·ç«¯ä¾èµ– 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.rocketmq\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;rocketmq-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 1.3.3 ä¿®æ”¹applications.yml 1 2 3 4 5 rocketmq: name-server: http://localhost:9876 producer: group: ${spring.application.name} send-message-timeout: 3000 1.4 æ¶æ„æ›´æ–° ç›®å‰æ¶æ„ï¼š\nä¸»çº¿ç¨‹ï¼šLua(Redisæ ¡éªŒä¸‹å•èµ„æ ¼ -\u0026gt; åˆ›å»ºè®¢å•è‡³Redis) -\u0026gt; å‘å¼‚æ­¥çº¿ç¨‹é˜»å¡é˜Ÿåˆ—æäº¤è®¢å•\nå­çº¿ç¨‹ï¼šå¼‚æ­¥çº¿ç¨‹è·å–åˆ†å¸ƒå¼é” -\u0026gt; æŒä¹…åŒ–è‡³æ•°æ®åº“(Transactional) -\u0026gt; è§£é”\nå…¶ä¸­åˆ†å¸ƒå¼é”çš„è®¾è®¡æ˜¯åŸæœ¬åœ¨å¤šå°Tomcatä¸‹ï¼Œä¼šå¯¼è‡´é‡å¤ä¸‹å•é—®é¢˜ã€‚ä½†ç°åœ¨Redisç”±äºæ˜¯ä¸²è¡ŒåŒ–çš„ï¼Œæ— è®ºå¤šå°‘å°Tomcatéƒ½ä¸ä¼šå‡ºç°å¹¶å‘é—®é¢˜ï¼Œä¸”MQä¹Ÿå°†åˆ›å»ºè®¢å•çš„æ¶ˆæ¯ä¸²è¡ŒåŒ–äº†ï¼Œæ•…åˆ†å¸ƒå¼é”å¯ä»¥å–æ¶ˆã€‚\næ›´æ–°åæ¶æ„ï¼š\nä¸»çº¿ç¨‹ï¼šLua(Redisæ ¡éªŒä¸‹å•èµ„æ ¼ -\u0026gt; åˆ›å»ºè®¢å•è‡³Redis) -\u0026gt; å‘MQç”Ÿäº§è®¢å•æ¶ˆæ¯\nå­çº¿ç¨‹ï¼šæ¶ˆè´¹MQæ¶ˆæ¯ -\u0026gt; æŒä¹…åŒ–è‡³æ•°æ®åº“(Transactional)\néœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨ç§’æ€åœºæ™¯ä¸‹ï¼Œç”¨æˆ·ä¸åº”è¯¥ä¸ºDBçš„é”™è¯¯ä¹°å•ï¼Œè€Œä¸”åˆ†å¸ƒå¼äº‹åŠ¡è¿èƒŒäº†å¼‚æ­¥ä¸‹å•æé«˜æ€§èƒ½çš„åˆè¡·ã€‚æ•…å¦‚æœDBæ›´æ–°å¤±è´¥ï¼Œä¸åº”è¯¥å›æ»šRedisï¼Œè€Œæ˜¯åº”è¯¥é‡è¯•DBæ›´æ–°æ“ä½œã€‚\n1.5 RocketMQåˆ†å¸ƒå¼äº‹åŠ¡é€»è¾‘ 1.6 ä»£ç å®ç° 1.6.1 MQé…ç½®ç±» 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Configuration public class RocketMQConfig { @Value(\u0026#34;${rocketmq.name-server}\u0026#34;) private String nameServer; // äº‹åŠ¡æ¶ˆæ¯ç”Ÿäº§è€… @Bean(initMethod = \u0026#34;start\u0026#34;, destroyMethod = \u0026#34;shutdown\u0026#34;) public TransactionMQProducer transactionProducer() { TransactionMQProducer producer = new TransactionMQProducer(\u0026#34;voucher_order_group\u0026#34;); producer.setNamesrvAddr(nameServer); producer.setTransactionListener(transactionListener()); // ç»‘å®šäº‹åŠ¡ç›‘å¬å™¨ return producer; } // äº‹åŠ¡ç›‘å¬å™¨å®ç° @Bean public TransactionListener transactionListener() { return new VoucherOrderTransactionListener(); } } ç®€å•ï¼Œè·³è¿‡ã€‚\n1.6.2 è®¢å•äº‹åŠ¡ç›‘å¬å™¨ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Component public class VoucherOrderTransactionListener implements TransactionListener { @Lazy @Resource private VoucherOrderServiceImpl voucherOrderService; // æ‰§è¡Œæœ¬åœ°äº‹åŠ¡ï¼ˆè®¢å•åˆ›å»ºï¼‰ @Override public LocalTransactionState executeLocalTransaction(Message msg, Object arg) { try { VoucherOrder order = JSON.parseObject(msg.getBody(), VoucherOrder.class); voucherOrderService.createVoucherOrder(order); // è°ƒç”¨è®¢å•åˆ›å»ºæ–¹æ³• return LocalTransactionState.COMMIT_MESSAGE; } catch (Exception e) { voucherOrderService.rollbackRedis(order.getVoucherId(), order.getUserId()); // éæ•°æ®åº“æ“ä½œå¯¼è‡´çš„å›æ»š return LocalTransactionState.ROLLBACK_MESSAGE; } } // äº‹åŠ¡å›æŸ¥ï¼ˆé˜²æ­¢æœ¬åœ°äº‹åŠ¡æœªæäº¤ï¼‰ @Override public LocalTransactionState checkLocalTransaction(MessageExt msg) { String orderId = msg.getKeys(); VoucherOrder order = voucherOrderService.getById(orderId); return order != null ? LocalTransactionState.COMMIT_MESSAGE : LocalTransactionState.ROLLBACK_MESSAGE; } } è¿™é‡Œå‡ ä¸ªå…³é”®ç‚¹ï¼š\n@Lazyï¼šç”±äºServiceä¸­æ³¨å…¥äº†transactionProducerï¼Œè€Œå…¶ä¾èµ–é…ç½®ç±»ä¸­åˆ›å»ºçš„TransactionListenerï¼Œæ•…äº§ç”Ÿå¾ªç¯ä¾èµ–ï¼Œéœ€è¦ä½¿ç”¨æ‡’åŠ è½½æ‰“ç ´å¾ªç¯ä¾èµ–ã€‚\nå›æ»šï¼šå¦‚æ³¨é‡Šã€‚\n1.6.3 ä¿®æ”¹ç§’æ€ä¸‹å•é€»è¾‘ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @Resource private TransactionMQProducer transactionProducer; @Override public Result seckillVoucher(Long voucherId) { Long userId = UserHolder.getUser().getId(); Long result = stringRedisTemplate.execute( SECKILL_SCRIPT, Collections.emptyList(), voucherId.toString(), userId.toString() ); int r = result.intValue(); if (r != 0) { return Result.fail(r == 1 ? \u0026#34;åº“å­˜ä¸è¶³\u0026#34; : \u0026#34;ä¸èƒ½é‡å¤ä¸‹å•\u0026#34;); } // ä¿å­˜order VoucherOrder order = new VoucherOrder(); order.setId(redisIdWorker.nextId(\u0026#34;order\u0026#34;)); order.setUserId(UserHolder.getUser().getId()); order.setVoucherId(voucherId); // æ„é€ æ¶ˆæ¯ Message msg = new Message(\u0026#34;voucher_order_topic\u0026#34;, JSON.toJSONBytes(order)); msg.setKeys(order.getId().toString()); try { transactionProducer.sendMessageInTransaction(msg, null); } catch (MQClientException e) { log.error(\u0026#34;MQé”™è¯¯\u0026#34;); } return Result.ok(order.getId()); } @Transactional public void createVoucherOrder(VoucherOrder voucherOrder) { Long userId = voucherOrder.getUserId(); Long voucherId = voucherOrder.getVoucherId(); boolean success = seckillVoucherService.update() .setSql(\u0026#34;stock = stock - 1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;, voucherId) .gt(\u0026#34;stock\u0026#34;, 0) // CASä¹è§‚é” .update(); if (!success) { // æ•°æ®åº“æ“ä½œå¤±è´¥ // 1. åˆ é™¤è´­ä¹°è®°å½• String key = RedisConstants.SECKILL_ORDER_KEY + voucherId; stringRedisTemplate.opsForSet().remove(key, userId.toString()); // 2. æ¢å¤é¢„æ‰£åº“å­˜ stringRedisTemplate.opsForValue() .increment(RedisConstants.SECKILL_STOCK_KEY + voucherId, 1); throw new RuntimeException(\u0026#34;æ•°æ®åº“æ‰£å‡å¤±è´¥\u0026#34;); } save(voucherOrder); } //å¹‚ç­‰Rediså›æ»š public void rollbackRedis(Long voucherId, Long userId) { String luaScript = \u0026#34;local orderKey = KEYS[1] \u0026#34; + \u0026#34;local stockKey = KEYS[2] \u0026#34; + \u0026#34;local userId = ARGV[1] \u0026#34; + // åªå›æ»šå­˜åœ¨çš„è®¢å•è®°å½• \u0026#34;if redis.call(\u0026#39;sismember\u0026#39;, orderKey, userId) == 1 then \u0026#34; + \u0026#34; redis.call(\u0026#39;srem\u0026#39;, orderKey, userId) \u0026#34; + \u0026#34; redis.call(\u0026#39;incr\u0026#39;, stockKey) \u0026#34; + // åº“å­˜+1 \u0026#34; return 1 \u0026#34; + \u0026#34;else \u0026#34; + \u0026#34; return 0 \u0026#34; + // å·²å¤„ç†æˆ–æ— è®°å½• \u0026#34;end\u0026#34;; String orderKey = RedisConstants.SECKILL_ORDER_KEY + voucherId; String stockKey = RedisConstants.SECKILL_STOCK_KEY + voucherId; // æ‰§è¡ŒLuaè„šæœ¬ Long result = stringRedisTemplate.execute( new DefaultRedisScript\u0026lt;\u0026gt;(luaScript, Long.class), Arrays.asList(orderKey, stockKey), userId.toString() ); log.debug(\u0026#34;å›æ»šç»“æœ: {}\u0026#34;, result); } ","date":"2025-06-01T00:00:00Z","permalink":"https://sixiyida.github.io/p/%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/","title":"ç‚¹è¯„é¡¹ç›®ä¼˜åŒ–"},{"content":"@Configurationå’Œ@Component @Configurationè‡ªèº«ä¹Ÿæ˜¯ä¸€ä¸ªBeanï¼Œé»˜è®¤å¯ç”¨ CGLIB ä»£ç†ï¼ˆproxyBeanMethods=trueï¼‰ã€‚å½“é…ç½®ç±»ä¸­çš„ @Bean æ–¹æ³•ç›¸äº’è°ƒç”¨æ—¶ï¼ŒSpring ä¼šæ‹¦æˆªè°ƒç”¨å¹¶è¿”å›å®¹å™¨ä¸­çš„å•ä¾‹ Beanï¼Œè€Œéé‡æ–°åˆ›å»ºï¼Œå¯ç›´æ¥æ³¨å…¥æ–¹æ³•å‚æ•°çš„Beanã€‚\n1 2 3 4 5 6 7 @Configuration public class Config { @Bean public A a() { return new A(); } @Bean public B b() { return new B(a()); } // æ³¨å…¥å®¹å™¨ä¸­çš„å•ä¾‹A } @Componentæ— ä»£ç†æœºåˆ¶ã€‚æ–¹æ³•é—´è°ƒç”¨è§†ä¸ºæ™®é€š Java æ–¹æ³•ï¼Œæ¯æ¬¡è°ƒç”¨ @Bean æ–¹æ³•éƒ½ä¼šåˆ›å»ºæ–°å®ä¾‹ï¼Œç ´åå•ä¾‹ï¼Œ ä¾èµ–æ³¨å…¥éœ€è¦æ˜¾å¼@Autowiredï¼š\n1 2 3 4 5 6 7 @Component public class ComponentConfig { @Bean public A a() { return new A(); } @Bean public B b() { return new B(a()); } // æ¯æ¬¡è°ƒç”¨a()åˆ›å»ºæ–°å®ä¾‹ï¼ } @PathVariable 1 2 3 4 @GetMapping(\u0026#34;/{id}\u0026#34;) public Result queryBlogById(@PathVariable(\u0026#34;id\u0026#34;) Long id) { } å°†urlçš„å€¼ç»‘å®šè‡³æ–¹æ³•å‚æ•°ä¸­ã€‚\n","date":"2025-05-30T00:00:00Z","permalink":"https://sixiyida.github.io/p/spring%E7%9B%B8%E5%85%B3/","title":"Springç›¸å…³"},{"content":"ä¸ºä»€ä¹ˆéœ€è¦æ¶ˆæ¯é˜Ÿåˆ—ï¼Ÿ åœ¨å¼‚æ­¥ä»»åŠ¡ï¼Œå¦‚ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹ä¸­ï¼Œä¸¤è€…çš„è¿è¡Œé€Ÿåº¦å¹¶ä¸ç›¸åŒï¼Œä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—å¯ä»¥åšä¸€ä¸ªç¼“å†²ï¼Œå‡å°ç³»ç»Ÿå‹åŠ›ã€‚\nRedisæ¶ˆæ¯é˜Ÿåˆ— 1. åŸºäºList Redisçš„listæ•°æ®ç»“æ„æ˜¯ä¸€ä¸ªåŒå‘é“¾è¡¨ï¼Œåˆ©ç”¨LPUSHå’ŒRPOPå®ç°ï¼Œè‹¥éœ€è¦é˜»å¡ï¼Œä½¿ç”¨BRPOPå®ç°é˜»å¡é˜Ÿåˆ—æ•ˆæœ\nç¼ºé™·ï¼šæ¯æ¬¡å–å‡ºæ¶ˆæ¯ç›´æ¥ä»é˜Ÿåˆ—ä¸­ç§»é™¤ï¼Œé€ æˆ\næ— æ³•é¿å…æ¶ˆæ¯ä¸¢å¤±ï¼šç§»é™¤åå¦‚æœå®•æœºï¼Œåˆ™æ¶ˆæ¯ä¸¢å¤±ã€‚ æ— æ³•æœ‰å¤šæ¶ˆè´¹è€…ï¼šåªèƒ½æ¶ˆè´¹ä¸€æ¬¡å¹¶ç§»é™¤ï¼Œæ— æ³•å¤šæ¬¡æ¶ˆè´¹ã€‚ 2. åŸºäºPub/Sub ç±»ä¼¼ROSï¼š\n1 2 3 SUBSCRIBE channel [channel] PUBLISH channel msg PSUBSCRIBE pattern [pattern] // è®¢é˜…åŒ¹é…patternçš„æ‰€æœ‰é¢‘é“ ç¼ºé™·ï¼šæ¯æ¬¡å–å‡ºæ¶ˆæ¯ç›´æ¥ä»é˜Ÿåˆ—ä¸­ç§»é™¤ï¼Œé€ æˆ\nä¸æ”¯æŒæ•°æ®æŒä¹…åŒ–ï¼šæ•°æ®ä¸åœ¨Redisï¼ˆå†…å­˜ï¼‰ä¸­ä¿å­˜ã€‚ æ— æ³•é¿å…æ¶ˆæ¯ä¸¢å¤±ï¼šå¦‚ä¸Šã€‚ æ¶ˆæ¯å †ç§¯æœ‰ä¸Šé™ï¼Œè¶…å‡ºæ—¶ä¸¢å¤±ï¼šåªåœ¨æ¶ˆè´¹è€…å¤„ç¼“å­˜ï¼Œæœ‰ä¸Šé™ã€‚ 3. åŸºäºStream Streamæ˜¯ä¸€ç§ä¸ºæ¶ˆæ¯é˜Ÿåˆ—è®¾è®¡çš„æ•°æ®ç±»å‹ã€‚\nåŸºæœ¬æ·»åŠ /è¯»å–æ¶ˆæ¯ 1 XADD users * name jack age 21 // å‘userå‘{name = jack, age = 21} 1 XREAD COUNT 1 BLOCK 2000 STREAMS users $ // è¯»usersæœ€æ–°çš„1ä¸ªæ¶ˆæ¯ï¼Œæ— æ¶ˆæ¯é˜»å¡2ç§’ æ¶ˆè´¹è€…ç»„ ç‰¹ç‚¹ï¼š\næ¶ˆæ¯åˆ†æµï¼šé˜Ÿåˆ—ä¸­æ¶ˆæ¯åˆ†æµè€Œä¸æ˜¯é‡å¤æ¶ˆè´¹ï¼ŒåŠ å¿«é€Ÿåº¦ã€‚ æ¶ˆæ¯è¡¨ç¤ºï¼šè®°å½•æœ€åä¸€ä¸ªè¢«å¤„ç†çš„æ¶ˆæ¯ï¼Œå®•æœºåä¹Ÿèƒ½æ¢å¤ã€‚ æ¶ˆæ¯ç¡®è®¤ï¼šæ¶ˆæ¯è¢«è·å–åå­˜å…¥pending-listï¼Œå¿…é¡»è¦æ¶ˆè´¹è€…ä½¿ç”¨XACKç¡®è®¤æ¶ˆæ¯ï¼Œæ‰ä¼šç§»é™¤ã€‚ 1 2 3 4 5 6 7 8 9 10 11 XGROUP CREATE mqName groupName ID [MKSTREAM] // ID(0):ç¬¬ä¸€ä¸ªæ¶ˆæ¯/ID($):æœ€åä¸€ä¸ªæ¶ˆæ¯ // ä¸ºmqNameåˆ›å»ºåä¸ºgroupNameçš„æ¶ˆè´¹è€…ç»„ XGROUP DESTROY mqName groupName XGROUP CREATECONSUMER mqName groupName consumerName XGROUP DELCONSUMER mqName groupName consumerName XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS mqName [mqName ...] ID [ID ...] //IDä¸ºè·å–æ¶ˆæ¯èµ·å§‹id //\u0026#34;\u0026gt;\u0026#34; : ä»æœªæ¶ˆè´¹æ¶ˆæ¯å¼€å§‹ //â€œæ•°å­—â€: ä»pending-listä¸­ç¬¬ä¸€ä¸ªæ¶ˆæ¯å¼€å§‹ RocketMQ NameServer-Broker NameServer æ˜¯ è½»é‡çº§çš„æœåŠ¡æ³¨å†Œä¸å‘ç°ä¸­å¿ƒï¼Œç±»ä¼¼äºåˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„â€œç”µè¯ç°¿â€æˆ–â€œç›®å½•æœåŠ¡â€ã€‚\nBroker æ˜¯æ¶ˆæ¯é˜Ÿåˆ—ä¸­å®é™…å­˜å‚¨ã€è½¬å‘æ¶ˆæ¯çš„æ ¸å¿ƒè§’è‰²ã€‚å®ƒæ˜¯ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ç›´æ¥æ‰“äº¤é“çš„èŠ‚ç‚¹ï¼ŒçœŸæ­£å¤„ç†æ¶ˆæ¯çš„å­˜å‚¨ã€æŸ¥è¯¢ã€æŠ•é€’ç­‰æ“ä½œã€‚\n","date":"2025-05-28T00:00:00Z","permalink":"https://sixiyida.github.io/p/message-queue/","title":"Message Queue"},{"content":"é” è¡Œçº§é” **è¡Œçº§é”ï¼š**åœ¨select for updateç­‰åœºæ™¯ï¼Œå³å½“å‰è¯»ï¼ˆå¦ä¸€ç§æ˜¯å¿«ç…§è¯»MVCCï¼‰åœºæ™¯ä½¿ç”¨ã€‚\nåŒ…æ‹¬Record Lock, Gap Lock å’Œ Next-key Lock(å‰ä¸¤ç§çš„åˆå¹¶)\nåŒ…æ‹¬X(Exclusive)å’ŒS(share)ä¸¤ç§\nGap Lockæ˜¯åªé”ç›¸é‚»ä¸¤æ¡è®°å½•ä¹‹é—´çš„()ï¼ŒNK-lockæ˜¯é”(]\nGap Lockçš„Xå’ŒSå‹æ˜¯ä¸€æ ·çš„ï¼Œéƒ½å¯ä»¥é‡å¤è·å–ï¼ŒNK-lockè¦çœ‹å³åŒºé—´çš„è®°å½•é”æ˜¯å¦äº’æ–¥ï¼Œæ— é™é™¤å¤–ã€‚\næ€ä¹ˆåŠ ï¼Ÿï¼ˆMySQL8.0.26, å¯é‡å¤è¯»ï¼‰ å¯¹ç´¢å¼•åŠ ï¼ŒåŸºæœ¬å•ä½æ˜¯nk-lockï¼Œä¸åŒæƒ…å†µå¯èƒ½å‡ºç°é€€åŒ–ä¸ºå‰ä¸¤ç§\nä¸»é”®ç´¢å¼•ç­‰å€¼æŸ¥è¯¢ï¼š\nè®°å½•å­˜åœ¨-\u0026gt;é€€åŒ–ä¸ºè®°å½•\nè®°å½•ä¸å­˜åœ¨-\u0026gt;é€€åŒ–ä¸ºé—´éš™é”\n1 select * from performance_schema.data_locks //æŸ¥åŠ äº†ä»€ä¹ˆé” å¦‚æœMODEæ˜¯GAPï¼Œ LOCK_DATAæ˜¯å³åŒºé—´ç•Œã€‚\nä¸»é”®ç´¢å¼•èŒƒå›´æŸ¥è¯¢ï¼š\nå¤§äºï¼šä¸é€€åŒ–\nå¤§äºç­‰äºï¼šå¦‚æœç­‰äºå­˜åœ¨ï¼Œåˆ™å·¦è¾¹é€€åŒ–ä¸ºè®°å½•é”ï¼Œä¸å­˜åœ¨åˆ™ä¸é€€åŒ–\nå°äºï¼šæœ€å³ä¾§é€€åŒ–ä¸ºé—´éš™é”\nå°äºç­‰äºï¼šè‹¥ç­‰äºå­˜åœ¨ï¼Œåˆ™ä¸é€€åŒ–ï¼Œä¸å­˜åœ¨åˆ™æœ€å³ä¾§é€€åŒ–ä¸ºé—´éš™é”\n**æ³¨ï¼š**è®°å½•é”å±äºè®°å½•ï¼Œåœ¨GAPé”ä¸­æ˜¯å±äºLOCK_DATAï¼Œå³åŒºé—´ç•Œçš„è®°å½•ã€‚\näºŒçº§ç´¢å¼•ï¼ˆéå”¯ä¸€ï¼‰ç­‰å€¼æŸ¥è¯¢ï¼š\nè®°å½•ä¸å­˜åœ¨ï¼šäºŒçº§ç´¢å¼•ä¸ŠGAPLOCKï¼Œå¯¹äºå·¦å³ç«¯ç‚¹ï¼Œèƒ½å¦æ’å…¥è¦çœ‹äºŒçº§ç´¢å¼•B+æ ‘ä¸‹ä¸€æ¡è®°å½•æœ‰æ— GAPLOCK\nè®°å½•ä¸å­˜åœ¨çš„ç‰¹æ®Šæƒ…å†µï¼šå¦‚æœæ˜¯è¶…è¿‡äº†æœ€å¤§idï¼Œæ˜¯next-keyLock\næ³¨ï¼šäºŒçº§ç´¢å¼•GAPLOCKçš„LOCK_DATAåŒ…å«ä¸¤ä¸ªå€¼ï¼ŒäºŒçº§ç´¢å¼•å’Œå›è¡¨çš„ä¸»é”®ç´¢å¼•\nè®°å½•å­˜åœ¨ï¼šå¯¹äºŒçº§ç´¢å¼•åŒ¹é…çš„è®°å½•åŠ nké”ï¼Œå¯¹ä¸åŒ¹é…çš„ç¬¬ä¸€ä¸ªnké”é€€åŒ–ä¸ºé—´éš™é”ï¼Œä¸”åœ¨ä¸»é”®ç´¢å¼•åŠ è®°å½•é”ã€‚\nå¯¹äºç«¯ç‚¹æ˜¯å¦èƒ½æ’å…¥ï¼Œå’Œè¦çœ‹äºŒçº§ç´¢å¼•B+æ ‘ä¸‹ä¸€æ¡è®°å½•æœ‰æ— LOCK\nåœ¨ä¸åŒ¹é…çš„ç¬¬ä¸€ä¸ªç´¢å¼•åŠ nké”çš„ç›®çš„ï¼šé˜²æ­¢å¹»è¯»ï¼ˆid \u0026gt; lock_idï¼‰çš„æƒ…å†µ\näºŒçº§ç´¢å¼•ï¼ˆéå”¯ä¸€ï¼‰èŒƒå›´æŸ¥è¯¢ï¼šä¸é€€åŒ–ï¼ŒäºŒçº§çš„nkå’Œä¸»é”®çš„è®°å½•é”éƒ½åŠ \nå¦‚æœä¸èµ°ç´¢å¼•å…¨è¡¨æ‰«æï¼Œåˆ™æ‰€æœ‰è®°å½•å…¨éƒ¨åŠ nké”ï¼Œå…¨é”ï¼Œæ˜¯äº‹æ•…\nè§£å†³æ–¹æ¡ˆï¼šå°†sql_safe_updatesè®¾ç½®ä¸º1ï¼Œæ­¤æ—¶å¿…é¡»ä½¿ç”¨where+ç´¢å¼• / limit\nå½“å‰è¯»çš„è¯­å¥ï¼šupdateã€deleteã€select for updateï¼Œä¼šåŠ æ„å‘é”å’Œè¡Œé”\næ­»é”çš„å½¢æˆ ä¾‹å­ï¼šå¦‚æœä¸¤ä¸ªäº‹åŠ¡éƒ½è·å–äº†é—´éš”é”ï¼Œä¸”å¸Œæœ›æ’å…¥å¯¹æ–¹é—´éš”ï¼Œåˆ™å°è¯•è·å–æ’å…¥æ„å‘é”ï¼ˆå’Œé—´éš”é”äº’æ–¥ï¼‰ï¼Œç¯è·¯ç­‰å¾…å¯¼è‡´æ­»é”ã€‚\ninsertè¯­å¥åŠ è¡Œçº§é” **è®°å½•ä¹‹é—´æœ‰é—´éš™é”ï¼š**åŠ æ’å…¥æ„å‘é”\næ³¨ï¼šmysqlçš„é”æ˜¯å…ˆç”Ÿæˆé”ç»“æ„ï¼Œé”æ­¤æ—¶æ˜¯ç­‰å¾…çŠ¶æ€ï¼Œå†è·å–é”ï¼Œå¦‚æœä¸èƒ½è·å–åˆ™é˜»å¡ã€‚\n**å”¯ä¸€é”®ï¼ˆä¸»é”®æˆ–å”¯ä¸€äºŒçº§ç´¢å¼•ï¼‰å†²çªï¼š**å¤±è´¥ååŠ Så‹é”\nä¸»é”®ï¼šåŠ Sè®°å½•é”\nå”¯ä¸€äºŒçº§ç´¢å¼•ï¼šåŠ Så‹NKé”\nä¾‹å­ï¼šåœ¨select for updateä¸­ï¼Œå°è¯•åŠ Xå‹é”ï¼Œå’ŒSå‹å†²çªï¼Œæ‰€ä»¥å¤±è´¥ã€‚\nå¹¶å‘insertå¯¼è‡´çš„å”¯ä¸€é”®å†²çª\nç¬¬ä¸€ä¸ªinsertä½†äº‹åŠ¡æ²¡æäº¤æ—¶ï¼Œæ„é€ éšå¼é”ã€‚\nç¬¬äºŒä¸ªinsertæ—¶ï¼Œéšå¼é”å˜æˆXå‹é”ï¼Œå’Œç¬¬äºŒä¸ªinsertæƒ³è¦è·å–çš„Så‹nké”å†²çª\né¿å…æ­»é”çš„æ–¹æ³• è®¾ç½®äº‹åŠ¡ç­‰å¾…å›æ»šæ—¶é—´ï¼šè¶…æ—¶å›æ»š\n1 innodb_lock_wait_timeout = 50 // default å¼€å¯ä¸»åŠ¨æ­»é”æ£€æµ‹ï¼šä¸»åŠ¨å›æ»š\n1 innodb_deadlock_detect = on æ—¥å¿— ä¿è¯ACIDç‰¹æ€§ï¼šAtomic, Consisitency, isolation, duration\nundo log æ³¨ï¼šå¯¹äºå¢åˆ æ”¹è¯­å¥ï¼Œinnodbä¼šéšå¼å¯åŠ¨äº‹åŠ¡ã€‚\nç‰¹æ®Šå¤„ç†ï¼šdeleteåªåœ¨è®°å½•ä¸Šæ‰“æ ‡è®°ï¼ŒçœŸæ­£åˆ é™¤ç”±purgeçº¿ç¨‹å®Œæˆ\nupdateéä¸»é”®åˆ—ï¼šç›´æ¥updateï¼Œä¸”åœ¨undologä¸­è®°å½•updateä¹‹å‰çš„å€¼\nupdateä¸»é”®åˆ—ï¼šå…ˆåˆ å†æ’\nundologçš„å­˜å‚¨å½¢å¼ï¼šç”±roll_pointeræŒ‡é’ˆå½¢æˆé“¾è¡¨ç©¿èµ·æ¥\nbufferpool æŒ‡çš„æ˜¯innodbå¼•æ“ä¸­çš„å†…å­˜bufferpoolã€‚\nç±»ä¼¼äºpagecacheï¼Œç”±åå°çº¿ç¨‹å®ç°è„é¡µå†™å›æœºåˆ¶ã€‚\nå†…å­˜ç»“æ„ï¼šé¦–å…ˆç”³è¯·è¿ç»­çš„å†…å­˜ç©ºé—´ï¼Œæ¥ç€æŒ‰ç…§16kbå¤§å°åˆ’åˆ†å‡ºç¼“å­˜é¡µã€‚\nåŒ…æ‹¬æ•°æ®é¡µã€ç´¢å¼•é¡µã€undoé¡µã€æ’å…¥ç¼“å­˜é¡µã€è‡ªé€‚åº”å“ˆå¸Œç´¢å¼•ã€é”ä¿¡æ¯ç­‰ã€‚\nredolog **redologçš„ä½œç”¨ï¼š**å¯¹ä¿®æ”¹å®ç°æŒä¹…åŒ–ã€‚\nWALæŠ€æœ¯(write-ahead logging)ï¼šåœ¨å†™å…¥ç£ç›˜ä¹‹å‰å…ˆå†™å…¥redologã€‚\næ¯å¯¹Bufferpoolè¿›è¡Œä¿®æ”¹å°±å†™å…¥redologï¼ŒåŒ…æ‹¬undologçš„ä¿®æ”¹\nredologå’Œundologå¯¹æ¯”ï¼š\nredologæ˜¯è®°å½•ä¿®æ”¹åï¼Œä¿è¯æŒä¹…åŒ–\nundologæ˜¯è®°å½•ä¿®æ”¹å‰ï¼Œä¿è¯åŸå­åŒ–\nå†™å…¥æ•°æ®å’Œå†™å…¥redologå¯¹æ¯”ï¼š\nredologï¼šæ˜¯é¡ºåºå†™å…¥ï¼Œé«˜æ•ˆ\næ•°æ®ï¼šæ˜¯éšæœºå†™å…¥ï¼Œä½æ•ˆ\nredologä¹Ÿæœ‰bufferï¼Œè½ç›˜æ—¶æœºï¼š\nmysqlæ­£å¸¸å…³é—­ï¼Œbufferç©ºé—´è¶…è¿‡ä¸€åŠï¼Œæ¯ä¸€ç§’å†™å›ä¸€æ¬¡ã€‚\ninnodb_flush_log_at_trx_commitå‚æ•°ï¼šæäº¤äº‹åŠ¡æ—¶çš„è¡Œä¸º\n0ï¼šä¸å†™å›ï¼Œåå°çº¿ç¨‹æ¯éš”ä¸€ç§’ç”¨write()å’Œfsync()\n1ï¼šç›´æ¥æŒä¹…åŒ–åˆ°ç£ç›˜\n2ï¼šå†™å…¥æ–‡ä»¶ï¼ˆpagecacheï¼‰ç”±æ“ä½œç³»ç»Ÿå†™å›ï¼Œåå°çº¿ç¨‹æ¯éš”ä¸€ç§’ç”¨fsync()\nredologå­˜å‚¨æ–¹å¼ï¼šä¸¤ä¸ªredologæ–‡ä»¶å¾ªç¯å­˜å‚¨ç±»ä¼¼äºç¯å½¢é˜Ÿåˆ—ã€‚\næœ‰ä¸ªtailå’Œheadï¼Œåœ¨tailå¤„å†™ï¼ŒæŒä¹…åŒ–bufferpoolè¿›å…¥æ•°æ®åæ›´æ–°headã€‚\nbinlog Serverå±‚çš„æ—¥å¿—ï¼Œ ç”¨äºå¤‡ä»½æ¢å¤ã€ä¸»ä»å¤åˆ¶ã€‚ä¸‰ç§æ ¼å¼ç±»å‹ï¼š\nSTATEMENTï¼šè®°å½•SQLè¯­å¥é€»è¾‘æ“ä½œ\nROWï¼šè®°å½•è¡Œæ•°æ®æœ€ç»ˆä¿®æ”¹æƒ…å†µ\nMIXEDï¼šæ ¹æ®æƒ…å†µä½¿ç”¨STATEMENTæˆ–è€…ROW\nä½¿ç”¨è¿½åŠ å†™ï¼Œå†™æ»¡æ–‡ä»¶å°±åˆ›å»ºæ–°æ–‡ä»¶ç»§ç»­å†™ï¼Œå…¨é‡æ—¥å¿—ã€‚\nä¸»ä»å¤åˆ¶ ä¸»åº“serverå±‚ç›´æ¥å†™å…¥binlogï¼Œåå°log dumpçº¿ç¨‹å¼‚æ­¥å°†binlogæ—¥å¿—å‘ç»™ä»åº“ï¼Œä»åº“relaylogè®°å½•binlogï¼Œåå°çº¿ç¨‹å¼‚æ­¥æ‰§è¡Œrelaylogã€‚\n**ä»åº“çš„æ•°é‡é€‰æ‹©ï¼š**å¯¹ä¸»åº“çš„èµ„æºæ¶ˆè€—ã€ç½‘ç»œå¸¦å®½ã€‚\nå…¶ä»–æ¨¡å‹ï¼š\nåŒæ­¥æ¨¡å‹ï¼šè¦æ‰€æœ‰ä»åº“relaylogè®°å½•å®Œæ¯•åè¿”å›æˆåŠŸï¼Œä¸»åº“å†è¿”å›å®¢æˆ·ç«¯ã€‚æ²¡æ³•ç”¨\nå¼‚æ­¥æ¨¡å‹ï¼šé»˜è®¤æ¨¡å‹ï¼Œä¸»åº“å®•æœºå°±gg\nåŠåŒæ­¥ï¼šä¸€éƒ¨åˆ†åº“è¿”å›æˆåŠŸå³å¯ã€‚\nbinlogä¹Ÿæœ‰cacheï¼Œæ¯ä¸ªçº¿ç¨‹å„ä¸€ä¸ªã€‚\næŒä¹…åŒ–çš„æ—¶æœºï¼š\nbinlog_cache_sizeï¼šè¶…è¿‡è¿™ä¸ªå¤§å°å°±å†™å…¥\nsync_binlogï¼š\n0ï¼šåªwriteï¼Œæ“ä½œç³»ç»Ÿæ§åˆ¶å†™å›\n1ï¼šwrite+fsync\nnï¼šwriteï¼Œç´¯ç§¯nä¸ªä»¥åfsync\næ³¨ï¼šbinlogåœ¨è¯­å¥æ‰§è¡Œå®Œæˆååœ¨è®°å½•ã€‚äº‹åŠ¡æäº¤æ—¶å€™æ‰æŒä¹…åŒ–ã€‚\nä¸¤é˜¶æ®µæäº¤ é—®é¢˜ï¼šå¦‚æœredologå’Œbinlogä¸€ä¸ªå®Œæˆä¸€ä¸ªä¸å®Œæˆï¼Œåˆ™ä¼šå‡ºç°ä¸»ä»ä¸ä¸€è‡´çš„é—®é¢˜ã€‚\nå†…éƒ¨XAäº‹åŠ¡ï¼šåœ¨äº‹åŠ¡æäº¤åå¼€å¯ï¼Œç”±binlogåè°ƒã€‚\nå°†redologå†™å…¥æ‹†ä¸ºprepareå’Œcommitï¼Œä¸­é—´æ’å…¥binlogæŒä¹…åŒ–ã€‚\nprepareï¼šå°†å†…éƒ¨XIDå†™å…¥redologå¹¶æŒä¹…åŒ–ï¼Œå°†çŠ¶æ€è®¾ç½®ä¸ºprepareã€‚\ncommitï¼šå°†å†…éƒ¨XIDå†™å…¥binlogå¹¶æŒä¹…åŒ–ï¼Œæ¥ç€å°†redologè®¾ç½®ä¸ºcommitã€‚\nå´©æºƒæ—¶ï¼Œredologå¤„äºprepareçŠ¶æ€ï¼Œæ£€æŸ¥binlogä¸­æœ‰æ— XAäº‹åŠ¡çš„idï¼Œæœ‰åˆ™æäº¤äº‹åŠ¡ï¼Œæ— åˆ™å›æ»šã€‚\n**é—®é¢˜ï¼š**æ€§èƒ½å·®\nç£ç›˜IOæ¬¡æ•°é«˜\nåœ¨å¤šäº‹åŠ¡ä¸‹ï¼Œä¸èƒ½ä¿è¯ä¸¤è€…æäº¤é¡ºåºä¸€è‡´ï¼Œéœ€è¦åŠ é”ä»¥ä¿è¯æäº¤çš„åŸå­æ€§\nä¸Šè¿°é—®é¢˜ï¼šbinlogç»„æäº¤æœºåˆ¶\nåˆ†ä¸ºflush(write)ã€sync(fsync)ã€commité˜¶æ®µï¼Œæ¯ä¸ªé˜¶æ®µéƒ½æœ‰é˜Ÿåˆ—ï¼Œç”¨é”ä¿è¯äº‹åŠ¡å†™å…¥é¡ºåºã€‚\nredologçš„ç»„æäº¤æœºåˆ¶\nå°†redologåˆ·ç›˜å»¶è¿Ÿåˆ°flushé˜¶æ®µä¸­\nBufferPool default = 128MB\neach page 16kb\nç»“æ„ï¼šæ§åˆ¶å—1åˆ°nï¼Œæ¥ç€page1åˆ°n\næ³¨ï¼šæŸ¥è¯¢æ—¶å€™ç›´æ¥å°†innodbçš„æ•´ä¸ªé¡µåŠ è½½è‡³bufferpoolä¸­ï¼Œç„¶ååœ¨bufferpoolä¸­é€šè¿‡é¡µç›®å½•å®šä½è®°å½•\nFREEé“¾è¡¨ï¼šç®¡ç†ç©ºé—²é¡µï¼ŒèŠ‚ç‚¹æ˜¯æ§åˆ¶å—ï¼Œå¤´ç»“ç‚¹åŒ…æ‹¬é“¾è¡¨å¤´å°¾åœ°å€å’Œæ§åˆ¶å—æ•°é‡ã€‚\nFLUSHé“¾è¡¨ï¼šç®¡ç†ç©ºé—²é¡µï¼ŒèŠ‚ç‚¹æ˜¯æ§åˆ¶å—ï¼Œå¤´ç»“ç‚¹åŒ…æ‹¬é“¾è¡¨å¤´å°¾åœ°å€å’Œæ§åˆ¶å—æ•°é‡ã€‚\nå¦‚ä½•ç®¡ç†bufferpoolï¼š\nä¼ ç»ŸLRUé—®é¢˜ï¼š\n**é¢„è¯»å¤±æ•ˆï¼š**é¢„è¯»æ—¶ä¼šæŠŠç›¸é‚»çš„æ•°æ®é¡µä¸€å¹¶åŠ è½½ï¼Œä¸ºäº†å‡å°‘ç£ç›˜IOï¼Œå¦‚æœè¿™äº›æ²¡æœ‰è¢«è®¿é—®ï¼Œä¸”æ·˜æ±°æœ«å°¾é¡µï¼Œåˆ™é™ä½ç¼“å­˜å‘½ä¸­ç‡ã€‚\n**è§£å†³æ–¹æ³•ï¼š**åˆ’åˆ†LRUçš„ä¼˜å…ˆçº§ï¼Œå‰é¢æ˜¯YOUNGï¼Œåé¢æ˜¯OLDï¼Œé¢„è¯»å…ˆåŠ å…¥OLDï¼ŒçœŸæ­£è®¿é—®æ‰åŠ å…¥YOUNGåŒºåŸŸã€‚\n**ç¼“å­˜æ±¡æŸ“ï¼š**å½“æ‰«æå¤§é‡æ•°æ®ï¼Œä¼šæ·˜æ±°å¤§é‡çƒ­æ•°æ®ï¼Œå¯¼è‡´å‘½ä¸­ç‡ä¸‹é™ã€‚\n**è§£å†³æ–¹æ³•ï¼š**æé«˜åŠ å…¥YOUNGçš„é—¨æ§›ï¼Œè®°å½•ç¬¬ä¸€æ¬¡OLDè¢«è®¿é—®çš„æ—¶é—´ï¼Œå¦‚æœåç»­è®¿é—®æ—¶é—´è¶…è¿‡ç¬¬ä¸€æ¬¡1sï¼Œåˆ™æ”¾å…¥youngåŒºåŸŸã€‚\n**Linuxçš„åšæ³•ï¼š**ç¬¬äºŒæ¬¡çš„æ—¶å€™å°†æ‰å‡çº§åˆ°activeï¼Œæ¯”MYSQLç®€å•ã€‚\n","date":"2025-05-28T00:00:00Z","permalink":"https://sixiyida.github.io/p/mysql/","title":"MySQL"},{"content":"ä¸ºä»€ä¹ˆéœ€è¦åˆ†å¸ƒå¼é”ï¼Ÿ åœ¨å•JVMç¯å¢ƒä¸­ï¼Œå¯¹äºä¸€äººä¸€å•çš„åœºæ™¯ï¼Œå¯ä»¥ä½¿ç”¨äº’æ–¥é”å®ç°ã€‚ä½†æ˜¯åœ¨è´Ÿè½½å‡è¡¡çš„é›†ç¾¤åœºæ™¯ä¸­ï¼Œéœ€è¦å…¨å±€é”ï¼Œå³åˆ†å¸ƒå¼é”ã€‚\nå¸¸è§çš„åˆ†å¸ƒå¼é”å®ç°æ–¹å¼ï¼šMySQLã€Redisã€Zookeeperã€‚\nMySQLåˆ†å¸ƒå¼é”å®ç°æ–¹å¼ï¼š\n1.åˆ©ç”¨å”¯ä¸€ç´¢å¼•ï¼Œæ’å…¥å”¯ä¸€é”®å€¼æˆåŠŸåˆ™è·å–é”ï¼Œé‡Šæ”¾é”åˆ™ç›´æ¥åˆ é™¤è¯¥è®°å½•ã€‚\n2.åˆ©ç”¨MySQLæ’ä»–é”ï¼ˆSELECT FOR UPDATEï¼‰ï¼Œæäº¤äº‹åŠ¡æ—¶é‡Šæ”¾é”ã€‚\nRedisåˆ†å¸ƒå¼é” åŠ é” 1 SET lock thread1 NX EX 10 1 Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId + \u0026#34;\u0026#34;, timeoutSec, TimeUnit.SECONDS); è§£é” 1 DEL lock 1 stringRedisTemplate.delete(KEY_PREFIX + name); è¯¯åˆ é—®é¢˜ ç”±äºå¯èƒ½å‡ºç°çº¿ç¨‹é˜»å¡è¶…æ—¶è‡ªåŠ¨é‡Šæ”¾ï¼Œä¸”é”åœ¨å½“å‰çº¿ç¨‹æ¢å¤ä¹‹å‰è¢«å…¶ä»–çº¿ç¨‹è·å–ï¼Œè¯¥çº¿ç¨‹æ¢å¤ä¹‹åå¦‚æœç›´æ¥é‡Šæ”¾é”ï¼Œä¼šé‡Šæ”¾å…¶ä»–çº¿ç¨‹è·å–çš„åˆ†å¸ƒå¼é”ï¼Œå‡ºç°æ··ä¹±ã€‚\nè§£å†³æ–¹æ³•ï¼š\nåˆ¤æ–­é”æ‰€æœ‰æƒï¼Œå†åˆ é™¤ã€‚é—®é¢˜ï¼šå½“åˆ¤æ–­æ‰€æœ‰æƒä¹‹åå¦‚æœçº¿ç¨‹é˜»å¡ï¼ŒåŒæ ·ä¼šå‡ºç°ä¸Šè¿°é—®é¢˜ã€‚ å°†1ä¸­æ“ä½œå˜æˆåŸå­çš„ï¼Œä½¿ç”¨Redisæä¾›çš„Luaè„šæœ¬ã€‚ 1 2 3 4 if (redis.call(\u0026#39;get\u0026#39;, KEYS[1]) == ARGV[1]) then return redis.call(\u0026#39;del\u0026#39;, KEYS[1]) end return 0 1 2 3 4 5 stringRedisTemplate.execute( UNLOCK_SCRIPT, Collections.singletonList(KEY_PREFIX + name), threadId ); åŸºäºsetnxå®ç°çš„åˆ†å¸ƒå¼é”çš„é—®é¢˜ ä¸å¯é‡å…¥ï¼šåŒçº¿ç¨‹æ— æ³•å¤šæ¬¡è·å–åŒä¸€æŠŠé”ï¼Œå¯èƒ½ä¼šå¯¼è‡´åŒçº¿ç¨‹ä¸åŒæ–¹æ³•ç›¸äº’ä¾èµ–å¯¼è‡´æ­»é”ã€‚ ä¸å¯é‡è¯•ï¼šè·å–é”å¤±è´¥æ²¡æœ‰é‡è¯•æœºåˆ¶ è¶…æ—¶é‡Šæ”¾ï¼šæ‰§è¡Œæ—¶é—´é•¿å¯èƒ½å¯¼è‡´é”æ„å¤–è‡ªåŠ¨è¶…æ—¶é‡Šæ”¾ã€‚ ä¸»ä»ä¸€è‡´æ€§ï¼šåŠ é”åä¸»èŠ‚ç‚¹å®•æœºï¼Œä»èŠ‚ç‚¹æœªåŒæ­¥ï¼Œå¯¼è‡´é‡å¤è·å–é”ã€‚ Redisson åŸºäºRediså®ç°çš„åˆ†å¸ƒå¼å·¥å…·ã€‚\nStep0ï¼šMavenæ·»åŠ ä¾èµ–\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.redisson\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;redisson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.22.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; **Step1ï¼š**æ³¨å…¥RedissonClient\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class RedissonConfig { @Bean public RedissonClient redissonClient(){ Config config = new Config(); config.useSingleServer().setAddress(\u0026#34;redis://localhost:6379\u0026#34;).setPassword(\u0026#34;password\u0026#34;); return Redisson.create(config); } } **Step2ï¼š**ä½¿ç”¨å·¥å…·\n1 RLock lock = redissonClient.getLock(RedisConstants.ORDER_LOCK_KEY + userId); Redissonåˆ†å¸ƒå¼é”åŸç† åŸºäºLuaè„šæœ¬çš„å¯é‡å…¥ åˆ©ç”¨hashç»“æ„ï¼Œè®°å½•çº¿ç¨‹idå’Œå¼•ç”¨æ¬¡æ•°ã€‚\nåŠ é”ï¼šåˆ¤æ–­æ˜¯å¦ä¸ºå½“å‰çº¿ç¨‹idï¼Œå¦‚æœæ˜¯ï¼Œåˆ™å¼•ç”¨è®¡æ•°+1ï¼Œé‡ç½®é”æœ‰æ•ˆæœŸã€‚\nè§£é”ï¼šåˆ¤æ–­æ˜¯å¦ä¸ºå½“å‰çº¿ç¨‹idï¼Œå¦‚æœä¸æ˜¯ï¼Œä¸ç”¨å¤„ç†ï¼›å¦‚æœæ˜¯ï¼Œåˆ™å¼•ç”¨è®¡æ•°-1å¹¶é‡ç½®é”æœ‰æ•ˆæœŸã€‚æœ€ååˆ¤æ–­å¦‚æœå¼•ç”¨è®¡æ•°ä¸º0ï¼Œåˆ™é‡Šæ”¾é”ã€‚\nå¯é‡è¯• åœ¨è§£é”æ—¶ä½¿ç”¨ä¿¡å·é‡/Pubï¼Œé€šçŸ¥è§£é”ã€‚\nåŠ é”å¤±è´¥åè‹¥æœ‰å‰©ä½™ç­‰å¾…æ—¶é—´ï¼Œæ”¶åˆ°è§£é”ä¿¡å·åï¼Œå¼‚æ­¥é‡è¯•ã€‚\né”ç»­æœŸ åŠ é”æˆåŠŸåå¯åŠ¨åå°çº¿ç¨‹Watchdogï¼Œæ¯10ç§’æ£€æŸ¥é”æ˜¯å¦è¢«æŒæœ‰ï¼Œè‹¥æŒæœ‰åˆ™ç»­æœŸä¸º30ç§’ã€‚\nMultiLock 1 Rlock lock = redissonClient.getMulitLock(lock1, lock2, ...); åŸç†ï¼š\nè·å–é”ï¼šéå†è·å– + å¤±è´¥å›æ»š\nå»ºç«‹é”Listï¼Œéå†è·å–é”ï¼Œéå†æ—¶åˆ†é…æ¯ä¸ªé”çš„ç­‰å¾…æ—¶é—´ã€‚\nè‹¥å‡ºç°è·å–å¤±è´¥ï¼Œåˆ™é‡Šæ”¾æ‰€æœ‰å·²ç»è·å–çš„é”ï¼Œå¹¶è¿”å›å¤±è´¥ã€‚\nå¦‚æœæ‰€æœ‰é”è·å–æˆåŠŸåˆ™è¿”å›æˆåŠŸã€‚\nè§£é”ï¼šéå†é‡Šæ”¾ + å¼‚å¸¸å®¹å¿\néå†æ‰€æœ‰é”å¹¶é€ä¸€é‡Šæ”¾ï¼ˆæ— è®ºæ˜¯å¦å±äºå½“å‰çº¿ç¨‹ï¼‰ã€‚\nå³ä½¿æŸä¸ªé”é‡Šæ”¾å¤±è´¥ï¼ˆå¦‚é”å·²è¶…æ—¶ï¼‰ï¼Œä»ç»§ç»­é‡Šæ”¾å…¶ä»–é”ï¼Œæœ€å¤§é™åº¦é¿å…æ­»é”ã€‚\n","date":"2025-05-28T00:00:00Z","permalink":"https://sixiyida.github.io/p/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","title":"Redisåˆ†å¸ƒå¼é”"},{"content":"é™æ€ä»£ç å—åˆå§‹åŒ– 1 2 3 4 5 static { UNLOCK_SCRIPT = new DefaultRedisScript\u0026lt;\u0026gt;(); UNLOCK_SCRIPT.setLocation(new ClassPathResource(\u0026#34;unlock.lua\u0026#34;)); UNLOCK_SCRIPT.setResultType(Long.class); } åœ¨ç±»é¦–æ¬¡åŠ è½½æ—¶æ‰§è¡Œä¸€æ¬¡ï¼Œå¦‚é€šè¿‡newåˆ›å»ºå¯¹è±¡ã€è®¿é—®é™æ€æˆå‘˜æˆ–åå°„åŠ è½½ç±»æ—¶è§¦å‘\nå¤šä¸ªé™æ€ä»£ç å—æŒ‰å®šä¹‰é¡ºåºä¾æ¬¡æ‰§è¡Œ\nå¯ä»¥è¿›è¡Œå¤æ‚é€»è¾‘åˆå§‹åŒ–\néé™æ€æˆå‘˜å˜é‡åˆå§‹åŒ– åœ¨å¯¹è±¡åˆ›å»ºæ—¶å®Œæˆï¼Œé¡ºåºä¸ºå£°æ˜èµ‹å€¼ â†’ åˆå§‹åŒ–å— â†’ æ„é€ å‡½æ•°ï¼Œæ¯ç§ä¸ä»£ç ä¹¦å†™é¡ºåºä¸€è‡´ã€‚\nSpringBootä¸­çš„classpath ä¸€å¥è¯æ€»ç»“ï¼šclasspath ç­‰ä»·äº main/java + main/resources + ç¬¬ä¸‰æ–¹jaråŒ…çš„æ ¹ç›®å½•ã€‚\n1 UNLOCK_SCRIPT.setLocation(new ClassPathResource(\u0026#34;unlock.lua\u0026#34;)); ClassPathResourceå¯¹åº”main/resourcesç›®å½•ä¸‹æ–‡ä»¶ã€‚\nAOPçš„å†…éƒ¨è°ƒç”¨é—®é¢˜ åœ¨ä½¿ç”¨AOPçš„åœºæ™¯ä¸­ï¼Œå¦‚@Transactionalï¼Œå¦‚æœä½¿ç”¨thisæŒ‡é’ˆè°ƒç”¨å†…éƒ¨æ–¹æ³•ï¼Œä¼šç»•è¿‡ä»£ç†å¯¼è‡´AOPå¤±æ•ˆã€‚\nè§£å†³æ–¹æ³•ï¼š\nä½¿ç”¨AopContext.currentProxy()ç›´æ¥è·å–å½“å‰ä»£ç†å¯¹è±¡ï¼ŒåŸç†æ˜¯é€šè¿‡ ThreadLocal å­˜å‚¨å½“å‰çº¿ç¨‹çš„ä»£ç†å¯¹è±¡ã€‚ ç¼ºé™·ï¼šåœ¨å¤šçº¿ç¨‹åœºæ™¯ä¸‹ï¼Œå¦‚æœå­çº¿ç¨‹è°ƒç”¨çˆ¶çº¿ç¨‹çš„äº‹åŠ¡å‡½æ•°ï¼Œç”±äºThreadLocalä¸äº’é€šï¼Œå¯¼è‡´æ— æ³•è·å–ä»£ç†å¯¹è±¡ï¼Œäº‹åŠ¡å¤±æ•ˆã€‚\nç¼ºé™·çš„è§£å†³æ–¹æ³•ï¼šç›´æ¥åœ¨ä¸»çº¿ç¨‹ä¸­å°†è·å–çš„ä»£ç†å¯¹è±¡ä¼ ç»™å­çº¿ç¨‹ä»»åŠ¡ã€‚\nç›´æ¥ä½¿ç”¨@Autowiredå°†è‡ªèº«æ³¨å…¥ã€‚ **ç¼ºé™·ï¼š**å¾ªç¯ä¾èµ–é£é™©ï¼Œä¸‰çº§ç¼“å­˜æ€§èƒ½ä½ã€‚\nRESTful APIï¼šPUT æ›´æ–°æˆ–åˆ›å»ºæŒ‡å®šä½ç½®çš„èµ„æºã€‚å®¢æˆ·ç«¯éœ€æä¾›å®Œæ•´çš„èµ„æºæ•°æ®ï¼ŒæœåŠ¡å™¨ä¼šå®Œå…¨æ›¿æ¢ç›®æ ‡ URI å¯¹åº”çš„èµ„æºã€‚è‹¥èµ„æºä¸å­˜åœ¨ï¼Œåˆ™æ–°å»ºèµ„æºã€‚\nä¸POSTå¯¹æ¯”ï¼š\nç‰¹æ€§ PUT POST å¹‚ç­‰æ€§ âœ… æ˜¯ï¼ˆå¤šæ¬¡è¯·æ±‚ç»“æœä¸€è‡´ï¼‰ âŒ å¦ï¼ˆå¯èƒ½äº§ç”Ÿå¤šä¸ªèµ„æºï¼‰ URI å«ä¹‰ èµ„æºå”¯ä¸€æ ‡è¯†ï¼ˆå¦‚ /users/123ï¼‰ èµ„æºé›†åˆï¼ˆå¦‚ /usersï¼‰ æ•°æ®å®Œæ•´æ€§ å¿…é¡»æä¾›å®Œæ•´èµ„æº å¯æäº¤éƒ¨åˆ†æ•°æ® å…¸å‹å“åº”ç  200 OKï¼ˆæ›´æ–°ï¼‰æˆ– 201 Createdï¼ˆæ–°å»ºï¼‰ 201 Createdï¼ˆæ–°å»ºèµ„æºï¼‰ @Resourceå’Œ@Autowiredå¯¹æ¯” @Resourceæµç¨‹\næŒ‡å®šname â†’ æŒ‰åç§°æŸ¥æ‰¾ â†’ å¤±è´¥æŠ›å¼‚å¸¸\næœªæŒ‡å®šname â†’ å…ˆæŒ‰å­—æ®µååŒ¹é… â†’ å¤±è´¥åˆ™æŒ‰ç±»å‹åŒ¹é…\næŒ‡å®štype â†’ æŒ‰ç±»å‹å”¯ä¸€åŒ¹é… â†’ å¤šåŒ¹é…æŠ›å¼‚å¸¸\n@Autowired æµç¨‹\næŒ‰ç±»å‹æŸ¥æ‰¾ â†’ æ‰¾åˆ°å”¯ä¸€ Bean â†’ æ³¨å…¥æˆåŠŸ\næ‰¾åˆ°å¤šä¸ªåŒç±»å‹ Bean â†’ éœ€ç»“åˆ @Qualifier(\u0026quot;beanName\u0026quot;) æŒ‡å®šåç§°\næ— åŒ¹é…ä¸”â†’ æ³¨å…¥required=false â†’ æ³¨å…¥ null\no instanceof Node nodeçš„ç”¨æ³•ï¼ˆJava 16+ï¼‰ ç­‰äºä»¥ä¸‹ä»£ç ï¼š\n1 2 3 if (o instanceof Node) { Node node = (Node) o; } recordï¼ˆJava 16+ï¼‰ 1 public record Person(String name, int age) {} è‡ªåŠ¨ç”Ÿæˆå†…å®¹ï¼š\nå…¨å‚æ„é€ å™¨ï¼ˆå¦‚Person(String name, int age)ï¼‰ å­—æ®µè®¿é—®å™¨ï¼ˆå¦‚name()ã€age()ï¼Œè€Œéä¼ ç»ŸgetName()ï¼‰ equals()ã€hashCode()ã€toString()æ–¹æ³• æ‰€æœ‰å­—æ®µé»˜è®¤ä¸ºfinalï¼Œå®ä¾‹åŒ–åä¸å¯ä¿®æ”¹\nthis() è°ƒç”¨å…¶ä»–æ„é€ å‡½æ•° 1 2 3 4 5 6 public record Edge(String sourceId, List\u0026lt;EdgeValue\u0026gt; targets) { // æ„é€ å‡½æ•° public Edge(String sourceId, EdgeValue target) { this(sourceId, List.of(target)); } } PECSåŸåˆ™ Producer Extends, Consumer Super.\n1 private static List\u0026lt;? extend K\u0026gt; produce() åŸå› ï¼šPEå¯ä»¥ä¿è¯è·å–çš„è‡³å°‘æ˜¯ä¸€ä¸ªKï¼Œè¿™æ ·è·å–å‡ºæ¥çš„å¯ä»¥ç›´æ¥ç”¨Kæ¥æ¥ï¼Œæ˜¯ç±»å‹å®‰å…¨çš„ã€‚\n1 private static consume(List\u0026lt;? super U\u0026gt;, U) åŸå› ï¼šCSå¯ä»¥ä¿è¯æ¥æ”¶æ¶ˆè´¹å¯¹è±¡çš„å®¹å™¨è£…çš„æ˜¯å…¶çˆ¶ç±»å¯¹è±¡ï¼Œå¯ä»¥ä¿è¯ä¼ å…¥çš„å¯¹è±¡å¯ä»¥è¢«å‘ä¸Šè½¬å‹ï¼Œæ˜¯ç±»å‹å®‰å…¨çš„ã€‚\nè‡ªå®šä¹‰Collector Collectoræ¥å£å®šä¹‰äº†5ä¸ªæ ¸å¿ƒæ–¹æ³•ï¼Œéœ€å…¨éƒ¨å®ç°ï¼š\nsupplier() åˆ›å»ºç»“æœå®¹å™¨ï¼ˆå¦‚ArrayList::newï¼‰ï¼Œç”¨äºå­˜å‚¨ä¸­é—´ç»“æœ\naccumulator() å®šä¹‰å¦‚ä½•å°†å…ƒç´ æ·»åŠ åˆ°å®¹å™¨ï¼ˆå¦‚List::addï¼‰ï¼Œå¤„ç†å•ä¸ªå…ƒç´ çš„ç´¯åŠ é€»è¾‘\ncombiner() åˆå¹¶å¹¶è¡Œæµçš„å­ç»“æœï¼ˆå¦‚åˆå¹¶ä¸¤ä¸ªListï¼šlist1.addAll(list2)ï¼‰ï¼Œéœ€ä¿è¯çº¿ç¨‹å®‰å…¨\nfinisher() å°†ä¸­é—´å®¹å™¨è½¬æ¢ä¸ºæœ€ç»ˆç»“æœï¼ˆå¦‚StringBuilder::toStringï¼‰ï¼Œå¯è¿›è¡Œæœ€ç»ˆè½¬æ¢æˆ–è¿‡æ»¤\ncharacteristics() è¿”å›æ”¶é›†å™¨ç‰¹æ€§çš„Setï¼Œå½±å“æ€§èƒ½ä¼˜åŒ–ï¼š\nCONCURRENTï¼šæ”¯æŒå¤šçº¿ç¨‹å¹¶å‘æ“ä½œå®¹å™¨ï¼ˆéœ€çº¿ç¨‹å®‰å…¨ï¼‰\nUNORDEREDï¼šç»“æœä¸å…ƒç´ é¡ºåºæ— å…³ï¼ˆå¦‚Setï¼‰\nIDENTITY_FINISHï¼šè·³è¿‡finisher()ï¼Œç›´æ¥è¿”å›ä¸­é—´å®¹å™¨\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private static \u0026lt;T, K, U\u0026gt; Collector\u0026lt;T, ?, Map\u0026lt;K, U\u0026gt;\u0026gt; toMapRemovingNulls(Function\u0026lt;? super T, ? extends K\u0026gt; keyMapper, Function\u0026lt;? super T, ? extends U\u0026gt; valueMapper, BinaryOperator\u0026lt;U\u0026gt; mergeFunction) { return Collector.of(HashMap::new, (map, element) -\u0026gt; { K key = keyMapper.apply(element); U value = valueMapper.apply(element); if (value == null) { map.remove(key); } else { map.merge(key, value, mergeFunction); } }, (map1, map2) -\u0026gt; { map2.forEach((key, value) -\u0026gt; { if (value != null) { map1.merge(key, value, mergeFunction); } }); return map1; }, Collector.Characteristics.UNORDERED); } Optionalå¯¹è±¡ å°†å¯èƒ½ä¸º null çš„å¯¹è±¡åŒ…è£…åœ¨ Optional å®¹å™¨ä¸­ï¼Œå¼ºåˆ¶å¼€å‘è€…æ˜¾å¼å¤„ç†ç©ºå€¼åœºæ™¯ã€‚\n1 Optional\u0026lt;String\u0026gt; name = Optional.ofNullable(getName()); æä¾› map(), flatMap(), filter() ç­‰æ–¹æ³•ï¼Œæ”¯æŒä»¥å‡½æ•°å¼é£æ ¼å¤„ç†å€¼ï¼š\n1 2 3 4 5 // é“¾å¼è·å–åµŒå¥—å±æ€§ï¼ˆé¿å…å¤šå±‚åˆ¤ç©ºï¼‰ String province = Optional.ofNullable(user) .map(User::getAddress) // è‹¥useréç©ºï¼Œæå–åœ°å€ .map(Address::getProvince) // è‹¥åœ°å€éç©ºï¼Œæå–çœä»½ .orElse(\u0026#34;æœªçŸ¥åœ°åŒº\u0026#34;); // è‹¥ä¸ºç©ºï¼Œè¿”å›é»˜è®¤å€¼ æ·±æ‹·è´çš„ä¸‰ç§æ–¹æ³• å®ç°cloneæ¥å£ï¼Œè¦æ±‚å¼•ç”¨å±æ€§å…¨éƒ¨å®ç°clonableæ¥å£ï¼Œé€’å½’è°ƒç”¨ã€‚ ç›´æ¥åºåˆ—åŒ–ç„¶åååºåˆ—åŒ–ï¼Œè¦æ±‚å¼•ç”¨å±æ€§å…¨éƒ¨å®ç°serializableæ¥å£ã€‚ æ‰‹åŠ¨é€’å½’å¤åˆ¶ã€‚ ","date":"2025-05-28T00:00:00Z","permalink":"https://sixiyida.github.io/p/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E9%9B%86/","title":"æ—¥å¸¸é—®é¢˜é›†"},{"content":"çº¿æ®µæ ‘ æ ¸å¿ƒæ€æƒ³ï¼šåˆ†æ²»\nèŠ‚ç‚¹ä¸Šç»´æŠ¤[l, r]çš„æŸä¸ªå€¼ï¼Œå·¦å„¿å­èŠ‚ç‚¹ç»´æŠ¤[l, mid]ï¼Œå³å„¿å­èŠ‚ç‚¹ç»´æŠ¤[mid + 1, r]ã€‚\nä¾‹é¢˜ï¼šLeetCode3479\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class SegmentTree{ vector\u0026lt;int\u0026gt; mx; void maintain(int o){ mx[o] = max(mx[o * 2], mx[o * 2 + 1]); } void build(const vector\u0026lt;int\u0026gt; \u0026amp; a, int o, int l, int r) { if (l == r) { mx[o] = a[l]; return; } int m = (l + r) / 2; build(a, o * 2, l, m); build(a, o * 2 + 1, m + 1, r); maintain(o); //æ›´æ–°çš„å…³é”®æ“ä½œ } public: SegmentTree(const vector\u0026lt;int\u0026gt; \u0026amp; a) { size_t n = a.size(); mx.resize(2 \u0026lt;\u0026lt; bit_width(n - 1));//? build(a, 1, 0, n - 1); } int findFirstAndUpdate(int o, int l, int r, int x) { if (mx[o] \u0026lt; x) { return -1; } if (l == r) { mx[o] = -1; return l; } int m = (l + r) /2; int i = findFirstAndUpdate(o * 2, l, m, x); if (i \u0026lt; 0) i = findFirstAndUpdate(o * 2 + 1, m + 1, r, x); maintain(o); return i; } }; Lazyçº¿æ®µæ ‘ ä¸ºä»€ä¹ˆlazyï¼Ÿ â€‹\tå¾…èŠ‚ç‚¹åŒºé—´å®Œå…¨åœ¨éœ€è¦æ›´æ–°çš„åŒºé—´å†…æ—¶ï¼Œåˆ™ä¸ç»§ç»­å‘ä¸‹æ›´æ–°ï¼Œè€Œæ˜¯æ ‡ä¸ºlazyæ ‡è®°ï¼Œå¾…ä¸‹ä¸€æ¬¡éœ€è¦æ›´æ–°åˆ°å­èŠ‚ç‚¹çš„æ—¶å€™ï¼Œå†æŠŠè¿™ä¸ªæ ‡è®°å‘ä¸‹ä¼ é€’ã€‚\nä¾‹é¢˜ï¼šLeetCode2569\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class LazySegmentTree{ private: vector\u0026lt;int\u0026gt; cnt; vector\u0026lt;int\u0026gt; todo; void maintain(int o) { cnt[o] = cnt[o * 2] + cnt[o * 2 + 1]; } void build(const vector\u0026lt;int\u0026gt; \u0026amp; a, int o, int l, int r) { if (l == r) { cnt[o] = a[l]; return; } int mid = (l + r) / 2; build(a, o * 2, l, mid); build(a, o * 2 + 1, mid + 1, r); maintain(o); } void reverse(int o, int l, int r) { cnt[o] = r - l + 1 - cnt[o]; todo[o] = !todo[o]; } public: LazySegmentTree(const vector\u0026lt;int\u0026gt; \u0026amp; a) { int n = a.size(); cnt.resize(4 * n); todo.resize(4 * n); build(a, 1, 0, n - 1); } void update(int o, int l, int r, int L, int R) { if (L \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= R) { //cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; reverse(o, l, r); return; } int m = (l + r) / 2; if (todo[o]) { reverse(o * 2, l, m); reverse(o * 2 + 1, m + 1, r); todo[o] = false; } if (m \u0026gt;= L) { update(o * 2, l, m, L, R); } if (m \u0026lt; R) { // m + 1 \u0026lt;= R update(o * 2 + 1, m + 1, r, L, R); } maintain(o); } int getRootVal() { return cnt[1]; } }; KMPç®—æ³• æ ¸å¿ƒæ€æƒ³ï¼šä¸»ä¸²æŒ‡é’ˆä¸åŠ¨ï¼Œå­ä¸²åŠ¨ã€‚å­ä¸²ä»next[sub_ptr]çš„ä½ç½®å¯åŠ¨ï¼Œnextçš„å«ä¹‰æ˜¯ä»[0, fail_sub_ptr]çš„å­ä¸²ä¸­ï¼Œç›¸åŒçš„æœ€é•¿çœŸå‰åç¼€é•¿åº¦ã€‚\n","date":"2025-04-28T00:00:00Z","permalink":"https://sixiyida.github.io/p/algorithms/","title":"Algorithms"}]